/ ********************************************
	- FERRAMENTAS TEMÁTICAS Ver. 1.0 -
	 Última atualização de ferramentas 27.02.2015
********************************************* /


/ *
* @fileOverview TouchSwipe - plugin do jQuery
* @version 1.6.9
*
* @ autor Matt Bryson http://www.github.com/mattbryson
* @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
* @see http://labs.skinkers.com/touchSwipe/
* @see http://plugins.jquery.com/project/touchSwipe
*
* Copyright (c) 2010 Matt Bryson
* Dupla licença sob as licenças MIT ou GPL Versão 2.
*
* /
(function (a) {if (typeof define === "function" && define.amd && define.amd.jQuery) {define (["jquery"], a)} else {a (jQuery)}} (função (f) { var y = "1.6.9", p = "esquerda", o = "direita", e = "para cima", x = "para baixo", c = "para dentro", A = "para fora", m = "nenhum" , s = "auto", l = "deslize", t = "pitada", B = "toque", j = "toque duplo", b = "longtap", z = "espera", E = "horizontal", u = "vertical", i = "tudo", r = 10, g = "início", k = "movimento", h = "final", q = "cancelamento", a = "início automático" na janela, v = janela .navigator.msPointerEnabled &&! window.navigator.pointerEnabled, d = window.navigator.pointerEnabled || window.navigator.msPointerEnabled, C = "TouchSwipe"; var n = {dedos: 1, limite: 75,cancelThreshold: null, pinchThreshold: 20, maxTimeThreshold: null, fingerReleaseThreshold: 250, longTapThreshold: 500, doubleTapThreshold: 200, swipe: null, swipeLeft: null, swipeRight: null, swipeUp: null, swipeDown: null, swipeStatus: null, pinipeIn: null, pinchOut: null, pinchStatus: null, clique em: null, toque em: null, doubleTap: null, longTap: null, mantenha: null, triggerOnTouchEnd: true, triggerOnTouchLeave: false, allowPageScroll: "auto", fallbackToMouseEvents: true, excluídosElements: "etiqueta, botão, entrada, seleção, área de texto, a, .noSwipe", preventDefaultEvents: true}; f.fn.swipetp = função (H) {var G = f (isto), F = G.data (C); if (F&& typeof H === "string") {if (F [H]) {return F [H] .apply (this, Array.prototype.slice.call (argumentos, 1))} else {f.error ( "Método" + H + "não existe no jQuery.swipetp")}} else {if (! F && (tipo de H === "objeto" ||! H)) {return w.apply (this, argument)}} return G}; f.fn.swipetp.version = y; f.fn.swipetp.defaults = n; f.fn.swipetp.phases = {PHASE_START: g, PHASE_MOVE: k, PHASE_END : h, PHASE_CANCEL: q}; f.fn.swipetp.directions = {ESQUERDA: p, DIREITA: o, UP: e, DOWN: x, IN: c, OUT: A}; f.fn.swipetp.pageScroll = {NENHUM: m, HORIZONTAL: E, VERTICAL: u, AUTO: s}; f.fn.swipetp.fingers = {UM: 1, DOIS: 2, TRÊS: 3, TODOS: i}; função w (F) { if (F && (F.allowPageScroll === undefined && (F.swipe! == undefined || F.swipeStatus! == undefined))) {F.allowPageScroll = m} if (F.clow! == undefined && F.tap = == indefinido) {F.tap = F.click} se (! F) {F = {}} F = f.extend ({}, f.fn.swipetp.defaults, F); retorne this.each (function () {var H = f (this); var G = H.data (C); if (! G) {G = new D (this, F); H.data (C, G)}})} função D (a5, aw) {var aA = (a || d ||! Aw.fallbackToMouseEvents), K = aA? (D? (V? "MSPointerDown": "apontador"): "touchstart"): "mousedown" ,az = aA? (d? (v? "MSPointerMove": "pointermove"): "touchmove"): "mousemove", V = aA? (d? (v? "MSPointerUp": "pointerup"): "touchend" ): "mouseup", T = aA? null: "mouseleave", aE = (d? (v? "MSPointerCancel": "pointercancel"): "touchcancel"); var ah = 0, aQ = null, ac = 0 , a2 = 0, a0 = 0, H = 1, ar = 0, aK = 0, N = nulo; var aS = f (a5); var aa = "início"; var X = 0; var aR = nulo; var U = 0, a3 = 0, a6 = 0, ae = 0, O = 0; var aX = nulo, ag = nulo; tente {aS.bind (K, aO); aS.bind (aE, ba)} catch (al) {f.error ("eventos não suportados" + K + "," + aE + "no jQuery.swipetp")} this.enable = function () {aS.bind (K, aO); aS.bind ( aE, ba); return aS}; this.disable = function () {aL (); return aS}; this.destroy = function () {aL (); aS.data (C, null); aS = null} ; this.option = função (bd, bc) {if (aw [bd]!== indefinido) {if (bc === indefinido) {retornar aw [bd]} else {aw [bd] = bc}} else {f.error ("Opção" + bd + "não existe no jQuery.swipetp. opções ")} retornar nulo}; função aO (be) {if (aC ()) {return} if (f (be.target) .closest (aw.excludedElements, aS) .length> 0) {return} var bf = be.originalEvent? be.originalEvent: be; var bd, bg = bf. toques, bc = bg? bg [0]: bf; aa = g; se (bg) {X = bg.length} outro {be. preventDefault ()} ah = 0; aQ = null; aK = null; ac = 0; a2 = 0; a0 = 0; H = 1; ar = 0; aR = ak (); N = ab (); S ( ); if (! bg || (X === aw.fingers || aw.fingers === i) || aY ()) {aj (0, bc); U = au (); if (X = = 2) {aj (1, bg [1]); a2 = a0 = av (aR [0] .start, aR [1] .start)} if (aw.swipeStatus || aw.pinchStatus) {bd = P (bf, aa)}} else {bd = false} if (bd === false) {aa = q; P (bf, aa); retornar bd} else {if (aw.hold) {ag = setTimeout (f .proxy (function () {disparador aS. ("hold", [bf.target]); if (aw.hold) {bd = aw.hold.call (aS, bf, bf.target)}}, this) aw.longTapThreshold)} ap (true)} retornar nulo} função a4 (bf) {var bi = bf.originalEvent? bf.originalEvent: bf; if (aa === h || aa === q || an ()) {return} var be, bj = bi.toca, bd = bj? bj [0]: bi; var bg = aI (bd); a3 = au (); if (bj) {X = bj.length} if ( aw.hold) {clearTimeout (ag)} aa = k; if (X == 2) {if (a2 == 0) {aj (1, bj [1]); a2 = a0 = av (aR [0] .start, aR [1] .start)} else {aI (bj [1]); a0 = av (aR [0] .end, aR [1] .end); aK = at (aR [0] .end , aR [1] .end)} H = a8 (a2, a0); ar = Math.abs (a2-a0)} if ((X === aw.fingers || aw.fingers === i) | |! bj || aY ()) {aQ = aM (bg.start, bg.end); am (bf, aQ); ah = aT (bg.start, bg.end); ac = aN (); aJ (aQ, ah); if (aw.swipeStatus || aw.pinchStatus) {be = P (bi, aa)} if (! aw.triggerOnTouchEnd || aw.triggerOnTouchLeave) {var bc = true; if (aw.triggerOnTouchLeave ) {var bh = aZ (this); bc = F (bg.end, bh)} if (! aw.triggerOnTouchEnd && bc) {aa = aD (k)} else {if (aw.triggerOnTouchLeave &&! bc) {aa = aD (h)}} se (aa == q || aa == h) {P (bi, aa)}}} mais {aa = q; P (bi,aa)} if (be === false) {aa = q; P (bi, aa)}} função M (bc) {var bd = bc.originalEvent? bc.originalEvent: bc, be = bd.touches; if (be) {if (be.length) {G (); return true}} if (an ()) {X = ae} a3 = au (); ac = aN (); if (bb () ||! ao ()) {aa = q; P (bd, aa)} else {if (aw.triggerOnTouchEnd || (aw.triggerOnTouchEnd == false && aa === k)) {bc.preventDefault (); aa = h; P (bd, aa)} else {if (! aw.triggerOnTouchEnd && a7 ()) {aa = h; aG (bd, aa, B)} else {if (aa === k) {aa = q; P (bd, aa)}}}} ap (false); retornar nulo} função ba () {X = 0; a3 = 0; U = 0; a2 = 0; a0 = 0; H = 1; S (); ap (false) )} função L (bc) {var bd = bc.originalEvent? bc.originalEvent: bc; if (aw.triggerOnTouchLeave) {aa = aD (h); P (bd, aa)}} função aL () {aS. Desvinculação (K, aO); aS.unbind (aE, ba); aS.unbind (az, a4); aS.unbind (V, M); if (T) {aS.unbind (T, L)} ap ( false)} função aD (bg) {var bf = bg; var be = aB (); var bd = ao (); var bc = bb (); if (! be || bc) {bf = q} else { if (bd && bg == k && (! aw.triggerOnTouchEnd || aw.triggerOnTouchLeave)) {bf = h} else {if (! bd && bg == h && aw.triggerOnTouchLeave) {bf = q}}} retornar bf} função P (be, bc) {var bd, bf = be.touches; if (( J () || W ()) || (Q () || aY ())) {if (J () || W ()) {bd = aG (seja, bc, l)} if ((Q () || aY ()) && bd! == false) {bd = aG (be, bc, t)}} else {if (aH () && bd! == false) {bd = aG (seja, bc, j )} else {if (aq () && bd! == false) {bd = aG (be, bc, b)} else {if (ai () && bd! == false) {bd = aG (be, bc, B )}}}} if (bc === q) {ba (be)} if (bc === h) {if (bf) {if (! bf.length) {ba (be)}} else {ba (be)}} retorne bd} função aG (bf, bc, be) {var bd; if (be == l) {aS.trigger ("swipeStatus", [bc, aQ || nulo, ah || 0, ac || 0, X, aR]); if (aw.swipeStatus) {bd = aw.swipeStatus.call (aS, bf, bc, aQ || nulo, ah || 0, ac || 0, X, aR ); if (bd === false) {return false}} if (bc == h && aW ()) {asS.trigger ("furto", [aQ, ah, ac, X, aR]); if (aw. deslize) {bd = aw.swipe.call (aS, bf, aQ, ah, ac, X, aR);if (bd === false) {return false}} switch (aQ) {case p: aS.trigger ("swipeLeft", [aQ, ah, ac, X, aR]); if (aw.swipeLeft) {bd = aw.swipeLeft.call (aS, bf, aQ, ah, ac, X, aR)} break; case o: aS.trigger ("swipeRight", [aQ, ah, ac, X, aR]); if ( aw.swipeRight) {bd = aw.swipeRight.call (aS, bf, aQ, ah, ac, X, aR)} break; case e: aS.trigger ("swipeUp", [aQ, ah, ac, X, aR]); if (aw.swipeUp) {bd = aw.swipeUp.call (aS, bf, aQ, ah, ac, X, aR)} break; case x: aS.trigger ("swipeDown", [aQ, ah, ac, X, aR]); if (aw.swipeDown) {bd = aw.swipeDown.call (aS, bf, aQ, ah, ac, X, aR)} pausa}}} if (be == t ) {aS.trigger ("pinchStatus", [bc, aK || nulo, ar || 0, ac || 0, X, H, aR]); if (aw.pinchStatus) {bd = aw.pinchStatus.call (aS, bf, bc, aK || nulo, ar || 0, ac || 0, X, H, aR); if (bd === false) {return false}} if (bc == h && a9 () ) {switch (aK) {case c: asStrigger ("pinchIn", [aK || null, ar || 0, ac || 0, X, H, aR]); if (aw.pinchIn) {bd = aw.pinchIn.call (aS, bf,aK || nulo, ar || 0, ac || 0, X, H, aR)} quebra; caso A: disparador aS. ("pinchOut", [aK || nulo, ar || 0, ac || 0 , X, H, aR]); if (aw.pinchOut) {bd = aw.pinchOut.call (aS, bf, aK || nulo, ar || 0, ac || 0, X, H, aR)} break}}} if (be == B) {if (bc === q || bc === h) {clearTimeout (aX); clearTimeout (ag); if (Z () &&! I ()) { O = au (); aX = setTimeout (f.proxy (função () {O = nulo; aS.trigger ("tap", [bf.target]); if (aw.tap) {bd = aw.tap. chamar (aS, bf, bf.target)}}, this), aw.doubleTapThreshold)} else {O = null; aS.trigger ("tap", [bf.target]); if (aw.tap) {bd = aw.tap.call (aS, bf, bf.target)}}}} else {if (be == j) {if (bc === q || bc === h) {clearTimeout (aX); O = null; aS.trigger ("doubletap", [bf.target]); if (aw.doubleTap) {bd = aw.doubleTap.call (aS, bf, bf.target)}}} else {if (be == b) {if (bc === q || bc === h) {clearTimeout (aX); O = null; aS.trigger ("longtap", [bf.target]); if (aw.longTap ) {bd = aw.longTap.call (aS, bf, bf.destino)}}}}} retornar bd} função ao () {var bc = true; if (aw.threshold! == null) {bc = ah> = aw.threshold} retornar bc} função bb () {var bc = false; if (aw.cancelThreshold! == null && aQ! == null) {bc = (aU (aQ) -ah)> = aw.cancelThreshold} retorna bc} função af () {if (aw.pinchThreshold! == null) {return ar> = aw.pinchThreshold} return true} função aB () {var bc; if (aw.maxTimeThreshold) {if (ac> = aw.maxTimeThreshold) {bc = false} else {bc = true}} else {bc = true} retornar bc} função am (bc, bd) {if (aw.preventDefaultEvents === false) {return} if (aw.allowPageScroll === m) {bc.preventDefault ()} else {var O que você precisa saber é que você pode criar uma lista com os itens que você deseja adicionar à lista de itens, como por exemplo: ((aw.swipeRight && be) || (! be && aw.allowPageScroll! = E)) {bc.preventDefault ()} break; case e: if ((aw.swipeUp && be) || (! be && aw.allowPageScroll! = u)) {bc.preventDefault ()} break; case x: if ((aw.swipeDown && be) || (! be && aw.allowPageScroll! = u)) {bc.preventDefault ()} break}}} função a9 () {var bd = aP (); var bc = Y (); var be = af (); retorna bd && bc && be} função aY () {return !! (aw.pinchStatus || aw.pinchIn || aw.pinchOut) } função Q () {return !! (a9 () && aY ())} função aW () {var bf = aB (); var bh = ao (); var be = aP (); var bc = Y () ; var bd = bb (); var bg =! bd && bc && be && bh && bf; return bg} função W () {return !! (aw.swipe || aw.swipeStatus || aw.swipeLeft || aw.swipeRight || aw.swipeUp | | aw.swipeDown)} função J () {retorno !! (aW () && W ())} função aP () {retorno ((X === aw.fingers || aw.fingers === i) || ! a)} função Y () {retornar aR [0] .end.x! == 0} função a7 () {retornar !! (aw.tap)} função Z () {retornar !! (aw.doubleTap) } função aV () {return !! (aw.longTap)} função R () {if (O == null) {return false} var bc = au (); return (Z () && ((bc-O) <= aw.doubleTapThreshold))} function I () {return R ()} função ay () {return ((X === 1 ||! a) && (isNaN (ah) || ah <aw.threshold))} função a1 () {return ((ac> aw.longTapThreshold) && (ah <r))} função ai () {return !! (ay () && a7 ())} função aH () {return !! (R () && Z ())} função aq () {return !! (a1 () && aV ())} função G () {a6 = au (); ae = event.touches.length + 1} função S () {a6 = 0; ae = 0} função an ( ) {var bc = false; if (a6) {var bd = au () - a6; if (bd <= aw.fingerReleaseThreshold) {bc = true}} retorna bc} função aC () {return !! (aS. data (C + "_ intouch") === true)} função ap (bc) {if (bc === true) {aS.bind (az, a4); aS.bind (V, M); if (T) {aS.bind (T, L)}} else {aS.unbind (az, a4, false); aS.unbind (V, M, false); if (T) {aS.unbind (T, L, false) }} aS.data (C + "_ intouch",bc === true)} função aj (bd, bc) {var be = bc.identifier! == indefinido? bc.identifier: 0; aR [bd] .identifier = be; aR [bd] .start.x = aR [bd] .end.x = bc.pageX || bc.clientX; aR [bd] .start.y = aR [bd] .end.y = bc.pageY || bc.clientY; retornar aR [bd] } função aI (bc) {var be = bc.identifier! == indefinido? bc.identifier: 0; var bd = ad (be); bd.end.x = bc.pageX || bc.clientX; bd.end .y = bc.pageY || bc.clientY; retornar bd} anúncio de função (bd) {for (var bc = 0; bc <comprimento de a.r; bc ++) {if (aR [bc] .identifier == bd) { retornar aR [bc]}}} função ak () {var bc = []; para (var bd = 0; bd <= 5; bd ++) {bc.push ({start: {x: 0, y: 0} , fim: {x: 0, y: 0}, identificador: 0})} retornar bc} função aJ (bc, bd) {bd = Math.max (bd, aU (bc)); N [bc] .distance = bd} função aU (bc) {se (N [bc]) {retornar N [bc] .distância} retornar indefinido} função ab () {var bc = {}; bc [p] = ax (p); bc [o] = ax (o); bc [e] = ax (e); bc [x] = ax (x); return bc} função ax (bc) {return {direction: bc, distance:0}} função aN () {retorna a3-U} função av (bf, be) {var bd = Math.abs (bf.x-be.x); var bc = Math.abs (bf.y-be. y); return Math.round (Math.sqrt (bd * bd + bc * bc))} função a8 (bc, bd) {var be = (bd / bc) * 1; return be.toFixed (2)} function at () {if (H <1) {return A} else {return c}} função aT (bd, bc) {retorna Math.round (Math.sqrt (Math.qow (Math.pow (bc.x-bd.x, 2 ) + Math.pow (bc.y-bd.y, 2))) função aF (bf, bd) {var bc = bf.x-bd.x; var bh = bd.y-bf.y; var O valor de x é: a) (bg = 0) (bg = 0) (bg = 360-Math.abs (bg)); bg = return bg}; função aM: b = Math.atan2 (bh, bc); var bg = Math.round (be * 180 / Math.PI); if (bg <0) (bd, bc) {var be = aF (bd, bc); if ((be <= 45) && (be> = 0)) {return p} else {if (((seja <= 360) && (be> = 315)) {return p} else {if ((be> = 135) && (be <= 225)) {return o} else {if ((be> 45) && (be <135)) {retorno x} else {return e}}}}} function au () {var bc = new Date (); return bc.getTime ()} function aZ (bc) {bc = f (bc); var be = bc.offset () ;var bd = {esquerda: be.left, direita: be.left + bc.outerWidth (), em cima: be.top, embaixo: be.top + bc.outerHeight ()}; retornar bd} função F (bc, bd ) {return (bc.x> bd.left && bc.x <bd.right && bc.y> bd.top && bc.y <bd.bottom)}}}));

if (typeof (console) === 'indefinido') {
    console var = {}
    console.log = console.error = console.info = console.debug = console.warn = console.trace = console.dir = console.dirxml = console.group = console.groupEnd = console.time = console.timeEnd = console. assert = console.profile = console.groupCollapsed = function () {};
}

if (window.tplogs == true)
	experimentar {
		console.groupCollapsed ("ThemePunch GreenSocks Logs");
	} captura (e) {}


var oldgs = window.GreenSockGlobals;
	oldgs_queue = window._gsQueue;
	
var punchgs = window.GreenSockGlobals = {};

if (window.tplogs == true)
	experimentar {
		console.info ("Construa o GreenSock SandBox para plugins ThemePunch");
		console.info ("Motor GreenSock TweenLite inicializado pelo ThemePunch Plugin");
	} captura (e) {}

/ *!
 * VERSÃO: 1.17.0
 * DATA: 27-05-2015
 * ATUALIZAÇÕES E DOCS EM: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. Todos os direitos reservados.
 * Este trabalho está sujeito aos termos em http://greensock.com/standard-license ou para
 * Membros do Club GreenSock, o contrato de software que foi emitido com a sua associação.
 * 
 * @ autor: Jack Doyle, jack@greensock.com
 * /
(função (t, e) {"use strict"; var i = t.GreenSockGlobals = t.GreenSockGlobals || t; if (! i.TweenLite) {var s, n, r, a, o, l = function ( t) {var e, s = t.split ("."), n = i; para (e = 0; s.length> e; e ++) n [s [e]] = n = n [s [e ]] || {}; retorno n}, h = l ("com.greensock"), _ = 1e-10, u = função (t) {var e, i = [], s = comprimento t; (e = 0; e! == s; i.push (t [e ++])); return i}, m = function () {}, f = function () {var t = Object.prototype.toString, e = t.call ([]); função de retorno (i) {return null! = i && (i instanceof Array || "object" == typeof i && !! i.push && t.call (i) === e)}} (), c = {}, p = função (s, n, r, a) {this.sc = c [s]? c [s] .sc: [], c [s] = isso, this.gsClass = null, this.func = r; var o = []; this.check = function (h) {for (var _, u, m, f, d = comprimento n, v = d; - d> - 1;) (_ = c [n [d]] || novo p (n [d], [])). GsClass? (O [d] = _. GsClass, v -): h && _. Sc.push (this); if (0 === v && r) para (u = ("com.greensock." + s).split ("."), m = u.pop (), f = l (u.join (".")) [m] = this.gsClass = r.apply (r, o), um && (i [m ] = f, "função" == tipo de definição && define.amd? define ((t.GreenSockAMDPath? t.GreenSockAMDPath + "/": "") + s.split ("."). pop (), [], function ( ) {return f}): s === e && "indefinido"! = tipo de módulo && module.exports && (module.exports = f)), d = 0; this.sc.length> d; d ++) this.sc [d] .check ()}, this.check (! 0)}, d = t._gsDefine = function (t, e, i, s) {retorna novo p (t, e, i, s)}, v = h. _classe = função (t, e, i) {retorno e = e || função () {}, d (t, [], função () {retorno e}, i), e}; d.globals = i; var g = [0,0,1,1], T = [], y = v ("alívio.Ease", função (t, e, i, s) {this._func = t, this._type = i || 0, this._power = s || 0, this._params = e? G.concat (e): g} ,! 0), w = y.map = {}, P = y.register = function ( t, e, i, s) {for (var n, r, a, o, l = e.split (","), _ = l.length,u = (i || "facilidadeIn, facilidadeOut, facilidadeInOut"). split (","); --_> - 1;) para (r = l [_], n = s? v ("flexibilização".) r, nulo,! 0): h.easing [r] || {}, a = u.length; - a> -1;) o = u [a], w [r + "." + o] = w [o + r] = n [o] = t.getRatio? t: t [o] || novo t}; for (r = protótipo, r._calcEnd =! 1, r.getRatio = função (t ) {if (this._func) retorna this._params [0] = t, this._func.apply (null, this._params); var e = this._type, i = this._power, s = 1 === e? 1-t: 2 === e? t: .5> t? 2 * t: 2 * (1-t); return 1 === i? s * = s: 2 === i? s * = s * s: 3 === i? s * = s * s * s: 4 === i && (s * = s * s * s * s), 1 === e? 1-s: 2 === e? s: .5> t? s / 2: 1-s / 2}, s = ["Linear", "Quad", "Cubic", "Quart", "Quint", "Quint, Strong"], n = s.length; - n> -1;) r = s [n] + ", Potência" + n, P (novo y (nulo, nulo, 1, n), r, "comfortOut",! 0) , P (novo y (nulo, nulo, 2, n), r, "facilidadeIn" + (0 === n? ", FacilidadeNenhum": "")), P (novo y (nulo, nulo, 3, n ), r "facilidadeInOut "); w.linear = h.easing.Linear.easeIn, w.swing = h.easing.Quad.easeInOut; var b = v (" events.EventDispatcher ", função (t) {this._listeners = {} , this._eventTarget = t || this}); r = b.prototype, r.addEventListener = function (t, e, i, s, n) {n = n || 0; var r, l, h = this ._listeners [t], _ = 0; for (null == h && (this._listeners [t] = h = []), l = h.length; - l> -1;) r = h [l] , rc === e && r.s === i? h.splice (l, 1): 0 === _ && n> r.pr && (_ = l + 1); h.splice (_, 0, {c: e, s: i, acima: s, pr: n}), isto! == a || o || a.wake ()}, r.removeEventListener = função (t, e) {var i, s = this ._listeners [t]; if (s) para (i = s.length; - i> -1;) if (s [i] .c === e) retorna s.splice (i, 1), void 0}, r.dispatchEvent = function (t) {var e, i, s, n = this._listeners [t]; if (n) for (e = n.length, i = this._eventTarget; - e> -1;) s = n [e], s && (s.up? Sccall (ss || i, {tipo: t, destino: i}): sccall (ss || i))}; var k = t. requestAnimationFrame, A = t.cancelAnimationFrame, S = Date.now || function () {return (new Date) .getTime ()}, x = S (); para (s = ["ms", "moz", "webkit", "o" ], n = s.length; - n> -1 &&! k;) k = t [s [n] + "RequestAnimationFrame"], A = t [s [n] + "CancelAnimationFrame"] || t [s [n] + "CancelRequestAnimationFrame"]; v ("Ticker", função (t, e) {vari, s, n, r, l, h = isto, u = S (), f = e! ==! 1 && k, c = 500, p = 33, d = "tick", v = função (t) {var e, a, o = S () - x; o> c && (u + = op), x + = o, h .time = (xu) /1e3,e=h.time-l, (! i || e> 0 || t ===! 0) && (h.frame ++, l + = e + (e> = r ?. 004: re), a =! 0), t! ==! 0 && (n = s (v)), a && h.dispatchEvent (d)}; b.call (h), h.time = h.frame = 0 , h.tick = função () {v (! 0)}, h.lagSmoothing = função (t, e) {c = t || 1 / _, p = Math.min (e, c, 0)}, h.sleep = function () {null! = n && (f && A? A (n): clearTimeout (n), s = m, n = nulo, h === a && (o =!1))}, h.wake = function () {null! == n? H.sleep (): h.frame> 10 && (x = S () - c + 5), s = 0 === i? m: f && k? k: função (t) {retornar setTimeout (t, 0 | 1e3 * (lh.time) +1)}, h === a && (o =! 0), v (2)}, h. fps = função (t) {retornar argumentos.length? (i = t, r = 1 / (i || 60), l = this.time + r, h.wake (), void 0): i}, h .useRAF = function (t) {return argument.length? (h.sleep (), f = t, h.fps (i), void 0): f}, h.fps (t), setTimeout (function () {f && 5> h.frame && h.useRAF (! 1)}, 1500)}), r = h.Ticker.prototype = new h.events.EventDispatcher, r.constructor = h.Ticker; var R = v ("core. Animação ", função (t, e) {if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number (e.delay) || 0 , this._timeScale = 1, this._active = e.immediateRender === 0, this.data = e.data, this._reversed = e.reversed ===! 0, B) {o || a.wake (); var i = this.vars.useFrames? q: B; i.add (this, i._time), this.vars.paused && this.pause (! 0)}}); a = R.ticker = novo h.Ticker, r = R.prototype, r._dirty = r._gc = r._initted = r._paused =! 1, r._totalTime = r ._time = 0, r._rawPrevTime = -1, r._next = r._last = r._onUpdate = r._timeline = r.timeline = null, r._paused =! 1; var C = function () {o && S ( ) - x> 2e3 && a.wake (), setTimeout (C, 2e3)}; C (), r.play = função (t, e) {return null! = t && this.seek (t, e), this.reversed ( ! 1) .paused (! 1)}, r.pause = function (t, e) {return null! = T && this.seek (t, e), this.paused (! 0)}, r.resume = function ( t, e) {return null! = t && this.seek (t, e), this.paused (! 1)}, r.seek = function (t, e) {retorna this.totalTime (Number (t), e! ==! 1)}, r.restart = function (t, e) {retorna this.reversed (! 1) .paused (! 1) .totalTime (t? -Este._delay: 0, e! ==! 1 ,! 0)}, r.reverse = function (t, e) {return null! = T && this.seek (t || this.totalDuration (), e), this.reversed (! 0) .paused (! 1) }, r.render = function () {}, r.invalidate = function () {return this._time = this._totalTime = 0, this._initted = this._gc =! 1, this._rawPrevTime = -1, (this._gc ||! this.timeline) && this._enabled ( ! 0), isso}, r.isActive = function () {var t, e = this._timeline, i = this._startTime; return! E ||! This._gc &&! This._paused && e.isActive () && (t = e.rawTime ())> = i && i + this.totalDuration () / this._timeScale> t}, r._enabled = função (t, e) {return o || a.wake (), this._gc =! t, this._active = this.isActive (), e! ==! 0 && (t &&! this.timeline? this._timeline.add (this, this._startTime-this._delay) :! t && this.timeline && this._timeline._remove (this,! 0)) ,! 1}, r._kill = function () {retorna this._enabled (! 1,! 1)}, r.kill = function (t, e) {retorna this._kill (t , e), isso}, r._uncache = função (t) {para (var e = t? this: this.timeline; e;) e._dirty =! 0, e = e.timeline; retorne isso}, r ._swapSelfInParams = function (t) {for (var e = comprimento, i = t.concat (); - e> -1;) "{self}" === t [e] && (i [e] = this); return i}, r._callback = function (t) {var e = this.vars; e [t] .apply (e [t + "Escopo"] || e.callbackScope || this, e [t + "Parâmetros"] || T)}, r.eventCallback = function (t, e, i, s) {if ("on" === (t || ""). Substr (0,2)) {var n = this.vars; if (1 === argumentos.length) retorna n [t]; null == e? delete n [t] :( n [t] = e, n [t + "Params"] = f (i) && - 1! == i.join (""). indexOf ("{self}")? this._swapSelfInParams (i): i, n [t + "Escopo"] = s), "onUpdate" = == t && (this._onUpdate = e)} retorne}, r.delay = function (t) {return argument.length? (this._timeline.smoothChildTiming && this.startTime (this._startTime + t-this._delay), this ._delay = t, this): this._delay}, r.duration = function (t) {return argument.length? (this._duration = this._totalDuration = t, this._uncache (! 0), this._timeline.smoothChildTiming && this._time> 0 && this._time <this._uration && 0! == t && this.totalTime (this._totalTime * (t / this._duration), ! 0), this) :( this._dirty =! 1, this._duration)}, r.totalDuration = function (t) {retorna this._dirty =! 1, argumentos.length? This.duration (t): this ._totalDuration}, r.time = function (t, e) {return argument.length? (this._dirty && this.totalDuration (), this.totalTime (t> this._duration? this._duration: t, e)): this ._time}, r.totalTime = função (t, e, i) {if (o || a.wake () ,! argument.length) retorna this._totalTime; if (this._timeline) {if (0> t && ! i && (t + = this.totalDuration ()), this._timeline.smoothChildTiming) {this._dirty && this.totalDuration (); var s = this._totalDuration, n = this._timeline; if (t> s &&! i && (t = s), isso._startTime = (este._pausado? este._pausaTempo: n._time) - (este._reverso? st: t) / desta._timeScale.n._dirty||este._uncache (! 1), n._timeline) para (; n._timeline;) n._timeline._time! == (n._startTime + n._totalTime) / n._timeScale&&n.totalTime (n._totalTime,! 0), n = n._timeline} this._gc && this._enabled (! 0,! 1), (this._totalTime! == t || 0 === this._duration) && (this.render (t, e,! 1), z.length && $ ())} retorne}, r.progress = r.totalProgress = função (t, e) {retornar argumentos.Comprimento? this.totalTime (esta.duração () * t, e): this._time / this.duration ()}, r.startTime = function (t) {return argument.length? (t! == this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add (this, t-this.delay)), this): this._startTime}, r.endTime = function (t) {return this._startTime + (0! = t? this.totalDuration (): this.duration ()) / this._timeScale}, r.timeScale = function (t) {if (! argument.length) retorna this._timeScale; if (t = t || _, this._timeline && this._timeline.smoothChildTiming) {var e = this._pauseTime, i = e || 0 === e? e: this._timeline.totalTime (); this._startTime = i- (i-this._startTime) * this._timeScale / t} retorna this._timeScale = t, this._uncache (! 1)}, r.reversed = função (t) {retornar argumentos.Comprimento? (T! = Isto._reverso && (este._reverso = t, este.totalTempo (this._timeline &&! This._timeline.smoothChildTiming? Isto totalDuration () - this._totalTime: this._totalTime,! 0)), this): this._reversed}, r.paused = function (t) {if (! argument.length) retorna this._paused; var e, i , s = this._timeline; return t! = this._paused && s && (o || t || a.wake (), e = s.rawTime (), i = e-this._pauseTime,! t && s.smoothChildTiming && (this. _startTime + = i, este._uncache (! 1)), este._pauseTime = t? e: nulo, este._pausado = t,this._active = this.isActive () ,! t && 0! == i && this._initted && this.duration () && this.render (s.smoothChildTiming? this._totalTime: (e-this._startTime) /this._timeScale,!0 ,! 0)), this._gc &&! T && this._enabled (! 0,! 1), this}; var D = v ("core.SimpleTimeline", função (t) {R.call (this, 0, t), this .autoRemoveChildren = this.smoothChildTiming =! 0}); r = D.prototype = new R, r.constructor = D, r.kill () ._ gc =! 1, r._first = r._last = r._recent = null, r._sortChildren =! 1, r.add = r.inserir = função (t, e) {vari, s; if (t._startTime = Number (e || 0) + t._delay, t._paused && this ! == t._timeline && (t._pauseTime = t._startTime + (this.rawTime () - t._startTime) /t._timeScale), t.timeline && t.timeline._remove (t,! 0), t.timeline = t ._timeline = this, t._gc && t._enabled (! 0,! 0), i = this._last, this._sortChildren) for (s = t._startTime; i && i._startTime> s;) i = i._prev; return i? (t._next = i._next, i._next = t) :( t._next = this._first, this._first = t), t._next? t._next. _prev = t: this._last = t, t._prev = i, this._recent = t, this._timeline && this._uncache (! 0), this}, r._remove = function (t, e) {return t.timeline === isso && (e || t._ ativado (! 1,! 0), t._prev? t._prev._next = t._next: this._first === t && (this._first = t._next), t._next? t._next._prev = t._prev: this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === isso ._recent && (this._recent = this._last), this._timeline && this._uncache (! 0)), this}, r.render = function (t, e, i) {var s, n = this._first; for ( this._totalTime = this._time = this._rawPrevTime = t; n;) s = n._next, (n._ativo || t> = n._startTime &&! n._paused) && (n._reversed? n.render ( (n._dirty? n.totalDuration (): n._totalDuration) - (tn._startTime) * n._timeScale, e, i): n.render ((tn._startTime) * n._timeScale, e, i)), n = s}, r.rawTime = function () {return o || a.wake (), this._totalTime}; var I = v ("TweenLite", função (e, i , s) {if (R.call (this, i, s), this.render = I.prototype.render, null == e) throw "Não é possível interpolar um destino nulo."; this.target = e = "string "! = tipo de e? e: I. seletor (e) || e; var n, r, a, o = e.jquery || comprimento e && e! == t && e [0] && (e [0] == = t || e [0] .nodeType && e [0] .style &&! e.nodeType), l = this.vars.overwrite; if (this._overwrite = l = null == l? Q [I.defaultOverwrite]: " número "== tipo de l? l >> 0: Q [l], (o || instância da matriz || e.push && f (e)) &&" número "! = tipo de e [0]) para (this._targets = a = u (e), this._propLookup = [], this._siblings = [], n = 0; a.length> n; n ++) r = a [n], r? "string"! = tipo de r ? r.length && r! == t && r [0] && (r [0] === t || r [0] .nodeType && r [0] .style &&! r.nodeType)? (a.splice (n -, 1), this._targets = a = a.concat (u (r))) :( this._siblings [n] = K (r, this,! 1), 1 === l && this._siblings [n] .length> 1 && J (r, this, null, 1, this._siblings [n])) :( r = a [n -] = I.seletor (r), " string "== tipo de r && a.splice (n + 1,1)): a.splice (n -, 1); caso contrário, this._propLookup = {}, this._siblings = K (e, this,! 1), 1 === l && this._siblings.length> 1 && J (e, isto, null, 1, this._siblings); (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender! = =! 1) && (this._time = -_, this.render (-th._delay))} ,! 0), E = function (e) {return e && e.length && e! == t && e [0] && (e [0] === t || e [0] .nodeType && e [0] .style &&! E.nodeType)}, O = função (t, e) {vari, s = {}; para (i em t) G [i] || i em e && "transformar"! == i && "x"! == i && "y"! == i && "width"! == i && "height"! == i && "className"! == i && "border"! == i ||! (! F [i] || F [i] && F [i] ._ autoCSS ) || (s [i] = t [i], excluir t [i]); t.css = s}; r = I.protótipo = novo R, r.construtor = I, r.qualidade () ._ gc =! 1, r.ratio = 0, r._firstPT = r._targets = r._overwrittenProps = r._startAt = nulo, r._notifyPluginsOfEnabled = r._lazy =! 1, I.version = "1.17.0", I .defaultEase = r._ease = novo y (nulo, nulo, 1,1), I.defaultOverwrite = "auto", I.ticker = a, I.autoSleep = 120, I.lagSmoothing = function (t, e) { a.lagSmoothing (t, e)}, I.selector = t. $ || t.jQuery || função (e) {var i = t. $ || t.jQuery; return i? (I.selector = i , i (e)): "indefinido" == tipo de documento? e: document.querySelectorAll? document.querySelectorAll (e): document.getElementById ("#" === e.charAt (0)? e.substr (1 ): e)}; var z = [], N = {}, L = I._internais = {isArray: f, isSeletor: E, lazyTweens: z},F = I._plugins = {}, U = L.tweenLookup = {}, j = 0, G = L.reservedProps = {facilidade: 1, atraso: 1, substituição: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope : 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1 , onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, facilidadeParams: 1, yoyo: 1, imediatRender: 1, repetição: 1, repeatDelay: 1, dados: 1, pausado: 1, invertido: 1, autoCSS: 1, preguiçoso : 1, onOverwrite: 1, callbackScope: 1}, Q = {none: 0, tudo: 1, automático: 2, simultâneo: 3, allOnStart: 4, preexistente: 5, "true": 1, "false": 0 }, q = R._rootFramesTimeline = novo D, B = R._rootTimeline = novo D, M = 30, $ = L.lazyRender = function () {var t, e = z.length; for (N = {}; --e> -1;) t = z [e], t && t._lazy! ==! 1 && (renderização (t._lazy [0], t._lazy [1] ,! 0), t._lazy = ! 1); z.length = 0}; B._startTime = a.time, q._startTime = a.frame, B._active = q._active =! 0, setTimeout ($, 1), R._updateRoot = I.render = function () {var t, e, i; if (z.length && $ ( ), B.render ((a.time-B._startTime) * B._timeScale,! 1,! 1), q.render ((a.frame-q._startTime) * q._timeScale,! 1,! 1 ), z.length && $ (), a.frame> = M) {M = a.frame + (parseInt (I.autoSleep, 10) || 120); for (i em U) {for (e = U [i ] .tweens, t = e.length; - t> -1;) e [t] ._ gc && e.splice (t, 1); 0 === e.length && delete U [i]} se (i = B. _primeiro, (! i || i._paused) && I.autoSleep &&! q._first && 1 === a._listeners.tick.length) {for (; i && i._paused;) i = i._next; i || a.sleep ()}}}, a.addEventListener ("tick", R._updateRoot); var K = função (t, e, i) {var s, n, r = t._gsTweenID; if (U [r || ( t._gsTweenID = r = "t" + j ++)] || (U [r] = {destino: t, pré-adolescentes: []}), e && (s = U [r] .tweens, s [n = s. comprimento] = e, i)) para (; - n> -1;) s [n] === e && s.splice (n, 1);return U [r] .tweens}, H = função (t, e, i, s) {var n, r, a = t.vars.onOverwrite; retorna a && (n = a (t, e, i, s) ), a = I.em sobrescrita, a && (r = a (t, e, i, s)), n! ==! 1 && r! ==! 1}, J = função (t, e, i, s, n ) {var r, a, o, l; if (1 === s || s> = 4) {for (l = n.length, r = 0; l> r; r ++) if ((o = n [r])! == e) o._gc || o._kill (null, t, e) && (a =! 0); caso contrário, se (5 === s) quebrar; retornar a} var h, u = e._startTime + _, m = [], f = 0, c = 0 === duração.d.; for (r = comprimento.n; - r> -1;) (o = n [r]) === e || o._gc || o._paused || (o._timeline! == e._timeline? (h = h || V (e, 0, c), 0 === V (o, h, c) && (m [f ++] = o)): u> = o._startTime && o._startTime + o.totalDuration () / o._timeScale> u && ((c ||! o._initted) && 2e-10> = uo._startTime || (m [f ++] = o))); para (r = f; - r> -1;) if (o = m [r], 2 === s && o._kill (i, t , e) && (a =! 0), 2! == s ||! o._firstPT && o._initted) {if (2! == s &&! H (o, e)) continue; o._ ativado (! 1, ! 1) && (a =!0)} retornar a}, V = função (t, e, i) {for (var s = timeline, n = s._timeScale, r = t._startTime; s._timeline;) {if (r + = s ._startTime, n * = s._timeScale, s._paused) return-100; s = s._timeline} return r / = n, r> e? re: i && r === e ||! t._initted && 2 * _> Re? _ :( r + = t.totalDuration () / t._timeScale / n)> e + _? 0: re -_}; r._init = function () {var t, e, i, s, n, r = this.vars, a = this._overwrittenProps, o = this._duration, l = !! r.immediateRender, h = r.ease; if (r.startAt) {this._startAt && (this._startAt.render (- 1,! 0), this._startAt.kill ()), n = {}; para (s em r.startAt) n [s] = r.startAt [s]; if (n. Sobrescrever =! 1, n .immediateRender =! 0, n.lazy = l && r.lazy! ==! 1, n.startAt = n.delay = null, this._startAt = I.to (this.target, 0, n), l) if ( this._time> 0) this._startAt = null; else if (0! == o) return} else if (r.runBackwards && 0! == o) if (this._startAt) this._startAt.render (-1 ,! 0), this._startAt.kill (), this._startAt = null;else {0! == this._time && (l =! 1), i = {}; para (s em r) G [s] e& "autoCSS"! == s || (i [s] = r [s ]); if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && r.lazy! ==! 1, i.immediateRender = l, this._startAt = I.to (this.target, 0, i), l) {if (0 === this._time) return} mais this._startAt._init (), this._startAt._enabled (! 1), this.vars.immediateRender && (this._startAt = null )} if (this._ease = h = h? h instância de y? ​​h: "function" == tipo de h? new y (h, r.easeParams): w [h] || I.defaultEase: I.defaultEase, r.easeParams instância da matriz && h.config && (this._ease = h.config.apply (h, r.easeParams)), this._easeType = this.ease__type, this._easePower = this._ease._power, this._firstPT = null, this._targets) para (t = this._targets.length; - t> -1;) this._initProps (this._targets [t], this._propLookup [t] = {}, this._siblings [t ], a? a [t]: null) && (e =! 0); caso contrário, e = isso._initProps (this.target, this._propLookup, this._siblings, a); if (e && I._onPluginEvent ("_ onInitAllProps", this), uma && (this._firstPT || "function"! = tipo dessa função e&&. 1,! 1)), r.runBackwards) para (i = this._firstPT; i;) i.s + = ic, ic = -ic, i = i._next; this._onUpdate = r.onUpdate, this.init =! 0}, r._initProps = function (e, i, s, n) {var r, a, o, l, h, _; if (null == e) retorna! 1; N [e._gsTweenID] && $ (), this.vars.css || e.style && e! == t && e.nodeType && F.css && this.vars.autoCSS! ==! 1 && O (this.vars, e); for (r in this.vars) {if (_ = this.vars [r], G [r]) _ && (_ instanceof Array || _.push && f (_)) && - 1! == _. join (""). indexOf ("{self}" ) && (this.vars [r] = _ = this._swapSelfInParams (_, this)); caso contrário, se (F [r] && (l = new F [r])) ._ onInitTween (e, this.vars [r] , this)) {for (this._firstPT = h = {_ next: this._firstPT, t: l, p: "setRatio", s: 0, c: 1, f:! 0, n: r, pg:! 0, pr: l._priority}, a = l._overwriteProps.length; - a> -1;) i [l._overwriteProps [a]] = this._firstPT; (l._priority || l._onInitAllProps) && (o =! 0), (l ._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled =! 0)} mais this._firstPT = i [r] = h = {_ próximo: this._firstPT, t: e, p: r, f: "function" == typeof e [r], n: r, pg:! 1, pr: 0}, hs = hf? e [r.indexOf ("conjunto") || "função"! = typeof e ["get" + r.substr (3)]? r: "get" + r.substr (3)] (): parseFloat (e [r]), hc = "string" == tipo de _ && "=" === _. charAt (1)? ParseInt (_. CharAt (0) + "1", 10) * Número (_. Substr (2)): Número (_) - hs || 0; h && h._next && (h._next._prev = h)} retornar n && this._kill (n, e)? this._initProps (e, i, s, n): this._overwrite> 1 && this._firstPT && s.comprimento> 1 && J (e, isto, i, isto., sobrescreva, s)? (este._kill (i, e), isto._initProps (e, i, s, n)) :( this._firstPT && (this.vars. preguiçoso! ==! 1 && this._duration || this.vars.lazy &&! this._uration) && (N [e._gsTweenID] =! 0), o)}, r.render = function (t, e, i) { var s, n, r, a, o = this._time, l = this._uration, h = this._rawPrevTime; if (t> = l) this._totalTime = this._time = l, this.ratio = this. _ease._calcEnd? this._ease.getRatio (1): 1, this._reversed || (s =! 0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && ( this._initted ||! this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0> h || h == = _ && "isPause"! == this.data) && h! == t && (i =! 0, h> _ && (n = "onReverseComplete")), this._rawPrevTime = a =! e || t || h = == t? t: _); caso contrário, se (1e-7> t) this._totalTime = this._time = 0,this.ratio = this._ease._calcEnd? this._ease.getRatio (0): 0, (0! == o || 0 === l && h> 0) && (n = "onReverseComplete", s = this._reversed ), 0> t && (this._active =! 1,0 === l && (this._initted ||! This.vars.lazy || i) && (h> = 0 && (h! == _ || "isPause "! == this.data) && (i =! 0), this._rawPrevTime = a =! e || t || h === t = t: _)), this._initted || (i =! 0); caso contrário, se (this._totalTime = this._time = t, this._easeType) {var u = t / l, m = this._easeType, f = this._easePower; (1 === m || 3 = == m && u> =. 5) && (u = 1-u), 3 === m && (u * = 2), 1 === f? u * = u: 2 === f? u * = u * u: 3 === f? u * = u * u * u: 4 === f && (u * = u * u * u * u), this.ratio = 1 === m? 1-u: 2 === m? U: .5> t / l? U / 2: 1-u / 2} mais this.ratio = this._ease.getRatio (t / l); if (this._time! == o || i) {if (! this._initted) {if (this._init () ,! this._initted || this._gc) return; if (! i && this._firstPT && (this.vars.lazy! ==! 1 &&this._duration || this.vars.lazy &&! this._duration)) retorna this._time = this._totalTime = o, this._rawPrevTime = h, z.push (isso), this._lazy = [t, e], void 0; this._time &&! s? this.ratio = this._ease.getRatio (this._time / l): s && this._ease._calcEnd && (this.ratio = this._ease.getRatio (0 === this._time? 0: 1))} para (este._ preguiçoso! ==! 1 && (este._ preguiçoso =! 1), este._ ativo ||! Isto._pausado && isto._time! == o && t> = 0 && (este._ativo =! 0 ), 0 === o && (this._startAt && (t> = 0? This._startAt.render (t, e, i): n || (n = "_ dummyGS")), this.vars.onStart && (0! == this._time || 0 === l) && (e || this._callback ("onStart"))), r = this._firstPT; r;) rf? rt [rp] (rc * this.ratio + rs): rt [rp] = rc * this.ratio + rs, r = r._next; this._onUpdate && (0> t && this._startAt && t! == - 1e-4 && this._startAt.render (t, e, i) ,e || (this._time! == o || s) && this._callback ("onUpdate")), n && (! this._gc || i) && (0> t && this._startAt &&! this._onUpdate && t! == - 1e-4 && this._startAt.render (t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled (! 1,! 1), this._active =! 1) ,! e && this.vars [n] && this.callback (n), 0 === l && this._rawPrevTime === _ && a! == _ && (this._rawPrevTime = 0))}}, r._kill = function (t, e, i) {if ("all" == = t && (t = null), null == t && (null == e || e === this.target)) retorna this._lazy =! 1, this._enabled (! 1,! 1); e = " string "! = typeof e? e || this._targets || this.target: I.selector (e) || e; var s, n, r, a, o, l, h, _, u, m = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline; if ((f (e) || E (e)) && "number"!= typeof e [0]) para (s = e.length; - s> -1;) this._kill (t, e [s], i) && (l =! 0); else {if (this. _targets) {for (s = this._targets.length; - s> -1;) if (e === this._targets [s]) {o = this._propLookup [s] || {}, this. _overwrittenProps = this._overwrittenProps || [], n = this._overwrittenProps [s] = t? this._overwrittenProps [s] || {}: "tudo"; pausa}} mais {if (e! == this.target ) return! 1; o = this._propLookup, n = this._overwrittenProps = t? this._overwrittenProps || {}: "all"} if (o) {if (h = t || o, _ = t! = = n && "tudo"! == n && t! == o && ("objeto"! = tipo de t ||! t._tempKill), i && (I.onOverwrite || this.vars.onOverwrite)) {for (r em h) o [r] && (u || (u = []), u.push (r)); if ((u ||! t) &&! H (this, i, e, u)) retornam! 1} Para (r em h) (a = o [r]) && (m && (af? at [ap] (as): at [ap] = as, l =! 0), a.pg && a.t._kill (h ) && (l =! 0), a.pg && 0! == em_overwriteProps.length || (a._prev? a._prev._next = a._next: a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev ), a._next = a._prev = null), exclua o [r]), _ && (n [r] = 1) ;! this._firstPT && this._initted && this._enabled (! 1,! 1)}} return l} , r.invalidate = function () {return this._notifyPluginsOfEnabled && I._onPluginEvent ("_ onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this. ._lazy =! 1, this._propLookup = this._targets? {}: [], R.prototype.invalidate.call (this), this.vars.immediateRender && (this._time = -_, this.render (-este ._delay)), this}, r._abled = function (t, e) {if (o || a.wake (), t && this._gc) {var i, s = this._targets; if (s) for ( i = s.length; - i> -1;) this._siblings [i] = K (s [i], this,! 0); mais this._siblings = K (this.target,this,! 0)} retorna R.prototype._enabled.call (this, t, e), this._notifyPluginsOfEnabled && this._firstPT? I._onPluginEvent (t? "_ onEnable": "_ onDisable", this) :! 1}, I .to = função (t, e, i) {retornar novo I (t, e, i)}, I.from = função (t, e, i) {retornar i.runBackwards =! 0, i.immediateRender = 0 ! = i.immediateRender, novo I (t, e, i)}, I.fromTo = função (t, e, i, s) {retornar s.startAt = i, s.immediateRender = 0! = s.immediateRender && 0! = i.immediateRender, novo I (t, e, s)}, I.delayedCall = função (t, e, i, s, n) {retorna novo I (e, 0, {atraso: t, onComplete: e, onCompleteParams: i, callbackScope: s, onReverseComplete: e, onReverseCompleteParams: i, imediatRender:! 1, lento:! 1, useFrames: n, substituição: 0})}, I.set = function (t, e) {return new I (t, 0, e)}, I.getTweensOf = function (t, e) {if (null == t) retorna []; t = "string"! = Typeof t? T: I.selector (t) || t; var i, s, n, r; se ((f (t) || E (t)) && "número"!= typeof t [0]) {for (i = t.length, s = []; - i> -1;) s = s.concat (I.getTweensOf (t [i], e)); for ( i = s.length; - i> -1;) para (r = s [i], n = i; - n> -1;) r === s [n] && s.splice (i, 1 )} else for (s = K (t) .concat (), i = s.length; - i> -1;) (s [i] ._ gc || e &&! s [i] .isActive ()) && s.splice (i, 1); return s}, I.killTweensOf = I.killDelayedCallsTo = function (t, e, i) {"objeto" == tipo de e && (i = e, e =! 1); for ( var s = I.getTweensOf (t, e), n = s.length; - n> -1;) s [n] ._ kill (i, t)}; var W = v ("plugins.TweenPlugin", function (t, e) {this._overwriteProps = (t || ""). split (","), this._propName = this._overwriteProps [0], this._priority = e || 0, this._super = W.prototype} ,! 0); if (r = W.prototype, W.version = "1.10.1", W.API = 2, r._firstPT = null, r._addTween = function (t, e, i , s, n, r) {var a, o; retorna nulo! = s && (a = "número" == tipo de s || "="! == s.charAt (1)? Número (s) -Número (i): parseInt (s.charAt (0) + "1", 10) * Número (s.substr (2)))? (this._firstPT = o = { _próximo: this._firstPT, t: t, p: e, s: i, c: a, f: "function" == tipo de t [e], n: n || e, r: r}, o._next && (o._next._prev = o), o): void 0}, r.setRatio = function (t) {for (var e, i = this._firstPT, s = 1e-6; i;) e = ic * t + é, ir? e = Math.round (e): s> e && e> -s && (e = 0), se? it [ip] (e): it [ip] = e, i = i._next} , r._kill = function (t) {var e, i = this._overwriteProps, s = this._firstPT; if (null! = t [this.propname]) this._overwriteProps = []; else for (e = i .length; - e> -1;) null! = t [i [e]] && i.splice (e, 1); para (; s;) null! = t [sn] && (s._next && (s ._next._prev = s._prev), s._prev? (s._prev._next = s._next, s._prev = null): this._firstPT === s && (this._firstPT = s._next)), s = s._next; return! 1}, r._roundProps = function (t, e) {for (var i = this._firstPT; i;) (t [this._propName] || null!= em && t [insplit (this._propName + "_"). join ("")]) && (ir = e), i = i._next}, I._onPluginEvent = function (t, e) {var i, s, n, r, a, o = e._firstPT; if ("_ onInitAllProps" === t) {for (; o;) {for (a = o._next, s = n; s && s.pr> o.pr; ); s = s._next; (o._prev = s? s._prev: r)? o._prev._next = o: n = o, (o._next = s)? s._prev = o: r = o , o = a} o = e._firstPT = n} para (; o;) o.pg && "function" == tipo de ot [t] && o.t [t] () && (i =! 0), o = o._next; return i}, W.activate = function (t) {for (var e = t.length; - e> -1;) t [e] .API === W.API && (F [( new t [e]) ._ propName] = t [e]); return! 0}, d.plugin = function (t) {if (! (t && t.propName && t.init && t.API)) lança "definição ilegal de plug-in". ; var e, i = t.propName, s = t.priority || 0, n = t.overwriteProps, r = {init: "_ onInitTween", conjunto: "setRatio", kill: "_ kill", round: "_roundProps ", initAll:" _ onInitAllProps "}, a = v (" plugins ". + i.charAt (0) .toUpperCase () + i.substr (1) +" Plugin ", function () {W.call (this , i, s), this._overwriteProps = n || []}, t.global ===! 0), o = a.prototype = new W (i); o.constructor = a, a.API = t .API; para (e em r) "função" == tipo de t [e] && (o [r [e]] = t [e]); retorne a.version = t.version, W.ativate ([a ]), a}, s = t._gsQueue) {for (n = 0; s.length> n; n ++) s [n] (); para (r em c) c [r] .func || t. console.log ("O GSAP encontrou dependência ausente: com.greensock." + r)} o =! 1}}) ("indefinido"! = tipo de módulo && module.exports && "indeterminado"! = tipo de global? global: esta || janela , "TweenLite");_overwriteProps = n || []}, t.global ===! 0), o = a.prototype = new W (i); o.constructor = a, a.API = t.API; for (e em r ) "function" == tipo de t [e] && (o [r [e]] = t [e]); retornar a.version = t.version, W.ativar ([a]), a}, s = t._gsQueue) {for (n = 0; s.length> n; n ++) s [n] (); for (r em c) c [r] .func || t.console.log ("GSAP encontrado ausente dependência: com.greensock. "+ r)} o =! 1}}) (" indefinido "! = tipo de módulo && module.exports &&" undefined "! = tipo de global? global: esta || janela," TweenLite ");_overwriteProps = n || []}, t.global ===! 0), o = a.prototype = new W (i); o.constructor = a, a.API = t.API; for (e em r ) "function" == tipo de t [e] && (o [r [e]] = t [e]); retornar a.version = t.version, W.ativar ([a]), a}, s = t._gsQueue) {for (n = 0; s.length> n; n ++) s [n] (); for (r em c) c [r] .func || t.console.log ("GSAP encontrado ausente dependência: com.greensock. "+ r)} o =! 1}}) (" indefinido "! = tipo de módulo && module.exports &&" undefined "! = tipo de global? global: esta || janela," TweenLite ");1}}) ("undefined"! = Tipo de módulo && module.exports && "undefined"! = Tipo de global? Global: esta || janela, "TweenLite");1}}) ("undefined"! = Tipo de módulo && module.exports && "undefined"! = Tipo de global? Global: esta || janela, "TweenLite");

/ *!
 * VERSÃO: 1.17.0
 * DATA: 27-05-2015
 * ATUALIZAÇÕES E DOCS EM: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. Todos os direitos reservados.
 * Este trabalho está sujeito aos termos em http://greensock.com/standard-license ou para
 * Membros do Club GreenSock, o contrato de software que foi emitido com a sua associação.
 * 
 * @ autor: Jack Doyle, jack@greensock.com
 * /
var _gsScope = "undefined"! = tipo de módulo && module.exports && "undefined"! = tipo de global? global: esta || janela; (_ gsScope._gsQueue || (_gsScope._gsQueue = [])). push (function () {" use strict "; _ gsScope._gsDefine (" TimelineLite ", [" core.Animation "," core.SimpleTimeline "," TweenLite "], função (t, e, i) {var s = function (t) {e.call (this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren ===! 0, this.smoothChildTiming = this.vars.smoothChildTiming ===! 0, this._sortChildren =! 0, this._onUpdate = this.vars.onUpdate; var i, s, r = this.vars; para (s em r) i = r [s], h (i) && - 1! == i.join ("" ) .indexOf ("{self}") && (r [s] = this._swapSelfInParams (i)); h (r.tweens) && this.add (r.tweens, 0, r.align, r.stagger)} , r = 1e-10, n = i._internals, a = s._internals = {}, o = n.isSelector, h = n.isArray, l = n.lazyTweens, _ = n.lazyRender, u = [], f = _gsScope._gsDefine.globals, c = função (t) {var e, i = {}; para (e em t) i [ e] = t [e]; return i}, p = a.pauseCallback = function (t, e, i, s) {var n, a = timeline_t, o = a._totalTime, h = t._startTime, l = 0> t._rawPrevTime || 0 === t._rawPrevTime && a._reversed, _ = l? 0: r, f = l? r: 0; if (e ||! this._forcingPlayhead) {for (a. pause (h), n = t._prev; n && n._startTime === h;) n._rawPrevTime = f, n = n._prev; para (n = t._next; n && n._startTime === h;) n ._rawPrevTime = _, n = n._next; e && e.apply (s || a.vars.callbackScope || a, i || u), (this._forcingPlayhead ||! a._paused) && a.seek (o) }}, m = função (t) {var e, i = [], s = comprimento de t; para (e = 0; e! == s; i.push (t [e ++])); return i} , d = s.prototype = new e; return s.version = "1.17.0", d.constructor = s, d.kill () ._ gc = d._forcingPlayhead =! 1, d.to = function (t, e, s, r) {var n = s.repeat && f.TweenMax || i; retorna e? this.add (novo n (t, e, s),r): this.set (t, s, r)}, d.from = function (t, e, s, r) {retorna this.add ((s.repeat && f.TweenMax || i) .de (t, e, s), r)}, d.fromTo = função (t, e, s, r, n) {var a = r.repeat && f.TweenMax || i; return e? this.add (a.fromTo (t , e, s, r), n): this.set (t, r, n)}, d.staggerTo = função (t, e, r, n, a, h, l, _) {var u, f = new s ({onComplete: h, onCompleteParams: l, callbackScope: _, smoothChildTiming: this.smoothChildTiming}); for ("string" == tipo de t && (t = i.seletor (t) || t), t = t || [], o (t) && (t = m (t)), n = n || 0,0> n && (t = m (t), t.reversa (), n * = - 1) , u = 0; t.length> u; u ++) r.startAt && (r.startAt = c (r.startAt)), f.to (t [u], e, c (r), u * n); retorna this.add (f, a)}, d.staggerFrom = function (t, e, i, s, r, n, a, o) {return i.immediateRender = 0! = i.immediateRender, i.runBackwards = ! 0, this.staggerTo (t, e, i, s, r, n, a, o)}, d.staggerFromTo = função (t, e, i, s, r, n, a, o, h) { retornar s.startAt = i, s.immediateRender = 0! = s.imediatoRender && 0! = i.immediateRender, this.staggerTo (t, e, s, r, n, a, o, h)}, d.call = function (t, e, s, r) {return this.add (i .delayedCall (0, t, e, s), r)}, d.set = function (t, e, s) {return s = this._parseTimeOrLabel (s, 0,! 0), null == e.immediateRender && (e.immediateRender = s === this._time &&! this._paused), this.add (novo i (t, 0, e), s)}, s.exportRoot = function (t, e) {t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming =! 0); var r, n, a = new s (t), o = a._timeline; for (null == e && (e =! 0 ), o._remove (a,! 0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._primeira; r;) n = r._next, e && r exemplo de i && r.target === r.vars.onComplete || a.add (r, r._startTime-r._delay), r = n; return o.add (a, 0), a}, d.add = função (r, n, a, o) {var l, _, u, f, c, p; if ("número"! = tipo de n && (n = this._parseTimeOrLabel (n, 0,! 0, r)) ,!(r instanceof t)) {if (r instanceof Array || r && r.push && h (r)) {for (a = a || "normal", o = o || 0, l = n, _ = r.length, u = 0; _> u; u ++) h (f = r [u]) && (f = new s ({tweens: f})), this.add (f, l), "string"! = tipo de f && "function"! = typeof f && ("sequence" === a? l = f._startTime + f.totalDuration () / f._timeScale: "start" === a && (f._startTime- = f.delay () )), l + = o; retorna this._uncache (! 0)} if ("string" == typeof r) retorna this.addLabel (r, n); if ("function"! = typeof r) throw "Não é possível adicionar "+ r +" na linha do tempo; não é uma interpolação, linha do tempo, função ou sequência. "; r = i.delayedCall (0, r)} if ((e.prototype.add.call (this, r, n)) , (this._gc || this._time === this._duration) &&! this._paused && this._duration <this.duration ()) para (c = this, p = c.rawTime ()> r._startTime; c ._timeline;) p && c._timeline.smoothChildTiming? c.totalTime (c._totalTime,! 0): c._gc && c._enabled (! 0,! 1), c = c._timeline; retorne isso}, d.remove = function (e) { if (e instanceof t) return this._remove (e,! 1); if (e instanceof Array || e && e.push && h (e)) {for (var i = e.length; - i> -1;) this .remove (e [i]); retorne isso} return "string" == tipo de e? this.removeLabel (e): esse.kill (nulo, e)}, d._remove = function (t, i) {e .prototype._remove.call (this, t, i); var s = this._last; return s? this._time> s._startTime + s._totalDuration / s._timeScale && (this._time = this.duration (), this._totalTime = this._totalDuration): this._time = this._totalTime = this._duration = this._totalDuration = 0, isto}, d.append = function (t, e) {retorna this.add (t, this. _parseTimeOrLabel (null, e,! 0, t))}, d.inserir = d.inserirMultiple = função (t, e, i, s) {retornar this.add (t, e || 0, i, s)} , d.appendMultiple = função (t, e, i,s) {retorna this.add (t, this._parseTimeOrLabel (nulo, e,! 0, t), i, s)}, d.addLabel = função (t, e) {retorna this._labels [t] = this ._parseTimeOrLabel (e), isto}, d.addPause = function (t, e, s, r) {var n = i.delayedCall (0, p, ["{self}", e, s, r], este ); return n.data = "isPause", this.add (n, t)}, d.removeLabel = function (t) {return delete this._labels [t], this}, d.getLabelTime = function (t) {return null! = this._labels [t]? this._labels [t]: - 1}, d._parseTimeOrLabel = function (e, i, s, r) {var n; if (r instanceof t && r.timeline == = this) this.remove (r); else if (r && (r instância de Array || r.push && h (r))) para (n = r.length; - n> -1;) r [n] instância de t && r [n] .timeline === this && this.remove (r [n]); if ("string" == typeof i) retorna this._parseTimeOrLabel (i, s && "number" == typeof e && null == this._labels [i ]? e-this.duration (): 0, s); se (i = i || 0, "string "! = tipo de e ||! isNaN (e) && null == this._labels [e]) null == e && (e = this.duration ()); else {if (n = e.indexOf (" = " ), - 1 === n) return null == this._labels [e]? S? This._labels [e] = this.duration () + i: i: this._labels [e] + i; i = parseInt (e.charAt (n-1) + "1", 10) * Número (e.substr (n + 1)), e = n> 1? this._parseTimeOrLabel (e.substr (0, n-1) , 0, s): this.duration ()} retorna Number (e) + i}, d.seek = function (t, e) {retorna this.totalTime ("number" == tipo de t? T: this._parseTimeOrLabel (t), e! ==! 1)}, d.stop = function () {retorna this.paused (! 0)}, d.gotoAndPlay = função (t, e) {retorna this.play (t, e )}, d.gotoAndStop = função (t, e) {retorna this.pause (t, e)}, d.render = função (t, e, i) {this._gc && this._enabled (! 0,! 1) ; var s, n, a, o, h, u = this._dirty? this.totalDuration (): this._totalDuration, f = this._time, c = this._startTime, p = this._timeScale, m = this. _pause; if (t> = u) isso._totalTime = this._time = u, this._reversed || this._hasPausedChild () || (n =! 0, o = "onComplete", h = !! this._timeline.autoRemoveChildren, 0 === this._duration && ( 0 === t || 0> this._rawPrevTime || this._rawPrevTime === r) && this._rawPrevTime! == t && this._first && (h =! 0, this._rawPrevTime> r && (o = "onReverseComplete")) ), this._rawPrevTime = this._duration ||! e || t || this._rawPrevTime === t? t: r, t = u + 1e-4; caso contrário, se (1e-7> t) if (this ._totalTime = this._time = 0, (0! == f || 0 === this._duration && this._rawPrevTime! == r && (this._rawPrevTime> 0 || 0> t && this._rawPrevTime> = 0)) && ( o = "onReverseComplete", n = this._reversed), 0> t) this._active =! 1, this._timeline.autoRemoveChildren && this._reversed? (h = n =! 0, o = "onReverseComplete"): this._rawPrevTime > = 0 && this._first && (h =! 0), este._rawPrevTime = t; else {if (this._rawPrevTime = this._duration ||! e || t || this._rawPrevTime === t? t: r, 0 === t && n) para (s = this._first; s && 0 === s._startTime;) s._duração || (n =! 1), s = s._next; t = 0, isso._iniciado || (h =! 0)} mais isso._totalTime = isso. _time = this._rawPrevTime = t; if (this._time! == f && this._first || i || h) {if (this._initted || (this._initted =! 0), this._active ||! this ._paused && this._time! == f && t> 0 && (this._active =! 0), 0 === f && this.vars.onStart && 0! == this._time && (e || this._callback ("onStart")), este. _time> = f) para (s = this._first; s && (a = s._next,! this._paused || m);) (s._active || s._startTime <= this._time &&! s._paused &&! s._gc) && (s._reversed? s.render ((s._dirty? s.totalDuration (): s._totalDuration) - (ts._startTime) * s._timeScale, e, i): s.render (( ts._startTime) * s._timeScale, e, i)),s = a; else for (s = this._last; s && (a = s._prev,! this._paused || m);) (s._active || f> = s._startTime &&! s._paused &&! s. _gc) && (s._reversed? s.render ((s._dirty? s.totalDuration (): s._totalDuration) - (ts._startTime) * s._timeScale, e, i): s.render ((ts. _startTime) * s._timeScale, e, i)), s = a; this._onUpdate && (e || (l.length && _ (), this._callback ("onUpdate"))), o && (this._gc || ( c === this._startTime || p! == this._timeScale) && (0 === this._time || u> = this.totalDuration ()) && (n && (comprimento.l && _ (), this._timeline) .autoRemoveChildren && this._enabled (! 1,! 1), this._active =! 1) ,! e && this.vars [o] && this._callback (o)))}}, d._hasPausedChild = function () {for (var t = this._first; t;) {if (t._paused || t instância de s && t._hasPausedChild ()) return! 0; t = t._next} return! 1}, d.getChildren = function (t, e, s ,r) {r = r || -9999999999; for (var n = [], a = this._first, o = 0; a;) r> a._startTime || (uma instância de i? e! ==! 1 && (n [o ++] = a) :( s! ==! 1 && (n [o ++] = a), t! ==! 1 && (n = n.concat (a.getChildren (! 0, e, s)) , o = n.length))), a = a._next; return n}, d.getTweensOf = function (t, e) {var s, r, n = this._gc, a = [], o = 0 ; para (n && this._enabled (! 0,! 0), s = i.getTweensOf (t), r = s.length; - r> -1;) (s [r] .timeline === this || e && this._contains (s [r])) && (a [o ++] = s [r]); return n && this._enabled (! 1,! 0), a}, d.recent = function () {return this._recent }, d._contains = function (t) {for (var e = timeline; e;) {if (e === isto) retorna! 0; e = e.timeline} retorna! 1}, d.shiftChildren = função (t, e, i) {i = i || 0; para (var s, r = this._first, n = this._labels; r;) r._startTime> = i && (r._startTime + = t) , r = r._next; se (e) para (s em n) n [s]> = i && (n [s] + = t); retorne this._uncache (! 0)}, d._kill = function ( t, e) {if (! t &&! e) retorna this._enabled (! 1,! 1); for (var i = e? this.getTweensOf (e): this.getChildren (! 0,! 0,! 1), s = i.length, r =! 1; - s> -1;) i [s] ._ kill (t, e) && (r =! 0); return r}, d.clear = function (t) {var e = this. getChildren (! 1,! 0,! 0), i = e.length; for (this._time = this._totalTime = 0; - i> -1;) e [i] ._ ativado (! 1,! 1 ); return t! ==! 1 && (this._labels = {}), this._uncache (! 0)}, d.invalidate = function () {for (var e = this._first; e;) e.invalidate (), e = e.next; retorna t.prototype.invalidate.call (this)}, d._abled = function (t, i) {if (t === this._gc) for (var s = this. _first; s;) s._enabled (t,! 0), s = s._next; return e.prototype._enabled.call (this, t, i)}, d.totalTime = function () {this._forcingPlayhead = ! 0; var e = t.prototype.totalTime.apply (this, argument); return this._forcingPlayhead =! 1, e}, d.duration = function (t) {return argument.length? (0! == this .duration () && 0! == t && this.timeScale (este._duration / t), this) :( this._dirty && this.totalDuration (), this._uration)}, d.totalDuration = function (t) {if (! argumentos.length) {if (this.dirty) {for (var e, i, s = 0, r = this._last, n = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration (), r._startTime> n && this._sortChildren &&! r._paused? this.add (r, r._startTime-r._delay): n = r._startTime, 0> r._startTime &&! r._paused && (s- = r._startTime, this._timeline.smoothChildTiming && (this._startTime + = r._startTime / this ._timeScale), this.shiftChildren (-r._startTime,! 1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i> s && (s = i), r = e; this._duration = this._totalDuration = s, this._dirty =! 1} retorne this._totalDuration} retorne 0! == this.totalDuration () && 0! == t && this.timeScale (this._totalDuration / t), este }, d.paused = function (e) {if (! e) for (var i = this._first,s = this._time; i;) i._startTime === s && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next; retorne t.prototype.paused.apply (this, argumentos)}, d.usesFrames = function () {for (var e = this._timeline; e._timeline;) e = e._timeline; return e === t._rootFramesTimeline}, d.rawTime = function () { return this._paused? this._totalTime: (this._timeline.rawTime () - this._startTime) * this._timeScale}, s} ,! 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () (), function (t) {"use strict"; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]}; "function" == tipo de definição && define.amd? define (["TweenLite"], e) : "undefined"! = tipo de módulo && module.exports && (require ("./ TweenLite.js"), module.exports = e ())} ("TimelineLite");data && (i._rawPrevTime = 0), i = i._next; retorna t.prototype.paused.apply (this, argumentos)}, d.usesFrames = function () {for (var e = this._timeline; e._timeline ;) e = e._timeline; return e === t._rootFramesTimeline}, d.rawTime = function () {retorna this._paused? this._totalTime: (this._timeline.rawTime () - this._startTime) * this ._timeScale}, s} ,! 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () (), function (t) {"use strict"; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope ) [t]}; "function" == tipo de definição && define.amd? define (["TweenLite"], e): "indefinido"! = tipo de módulo && module.exports && (require ("./ TweenLite.js"), módulo. exportações = e ())} ("TimelineLite");data && (i._rawPrevTime = 0), i = i._next; retorna t.prototype.paused.apply (this, argumentos)}, d.usesFrames = function () {for (var e = this._timeline; e._timeline ;) e = e._timeline; return e === t._rootFramesTimeline}, d.rawTime = function () {retorna this._paused? this._totalTime: (this._timeline.rawTime () - this._startTime) * this ._timeScale}, s} ,! 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () (), function (t) {"use strict"; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope ) [t]}; "function" == tipo de definição && define.amd? define (["TweenLite"], e): "indefinido"! = tipo de módulo && module.exports && (require ("./ TweenLite.js"), módulo. exportações = e ())} ("TimelineLite");_timeline; e._timeline;) e = e._timeline; return e === t._rootFramesTimeline}, d.rawTime = function () {retorna this._paused? this._totalTime: (this._timeline.rawTime () - este ._startTime) * this._timeScale}, s}, 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () () (), função (t) {"use strict"; var e = function () {return (_gsScope .GreenSockGlobals || _gsScope) [t]}; "function" == tipo de definição && define.amd? Define (["TweenLite"], e): "indefinido"! = Tipo de módulo && module.exports && (require ("./ TweenLite.js "), module.exports = e ())} (" TimelineLite ");_timeline; e._timeline;) e = e._timeline; return e === t._rootFramesTimeline}, d.rawTime = function () {retorna this._paused? this._totalTime: (this._timeline.rawTime () - este ._startTime) * this._timeScale}, s}, 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () () (), função (t) {"use strict"; var e = function () {return (_gsScope .GreenSockGlobals || _gsScope) [t]}; "function" == tipo de definição && define.amd? Define (["TweenLite"], e): "indefinido"! = Tipo de módulo && module.exports && (require ("./ TweenLite.js "), module.exports = e ())} (" TimelineLite ");use strict "; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]};" function "== tipo de define && define.amd? define ([" TweenLite "], e):" indefinido "! = typeof module && module.exports && (require ("./ TweenLite.js"), module.exports = e ())} ("TimelineLite");use strict "; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]};" function "== tipo de define && define.amd? define ([" TweenLite "], e):" indefinido "! = typeof module && module.exports && (require ("./ TweenLite.js"), module.exports = e ())} ("TimelineLite");


/ *!
 * VERSÃO: beta 1.15.2
 * DATA: 27/01/2015
 * ATUALIZAÇÕES E DOCS EM: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. Todos os direitos reservados.
 * Este trabalho está sujeito aos termos em http://greensock.com/standard-license ou para
 * Membros do Club GreenSock, o contrato de software que foi emitido com a sua associação.
 * 
 * @ autor: Jack Doyle, jack@greensock.com
 ** /
var _gsScope = "undefined"! = tipo de módulo && module.exports && "undefined"! = tipo de global? global: esta || janela; (_ gsScope._gsQueue || (_gsScope._gsQueue = [])). push (function () {" use strict "; _ gsScope._gsDefine (" easing.Back ", [" easing.Ease "], função (t) {var e, i, s, r = _gsScope.GreenSockGlobals || _gsScope, n = r.com.greensock , a = 2 * Math.PI, o = Math.PI / 2, h = n._classe, l = função (e, i) {var s = h ("flexibilização". + e, função () {}, ! 0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, s}, _ = t.register || function () {}, u = function (t, e, i, s) {var r = h ("flexibilização". + t, {facilidadeOut: novo e, facilidadeIn: novo i, facilidadeInOut: novo s} ,! 0); return _ (r, t), r}, c = função (t, e, i) {this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = iv-e, this.gap = it- t)}, f = função (e, i) {var s = h ("flexibilização". + e, função (t) {this._p1 = t || 0 === t? t: 1,70158,this._p2 = 1.525 * this._p1} ,! 0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, r.config = function (t) {return new s ( t)}, s}, p = u ("Back", f ("BackOut", função (t) {return (t- = 1) * t * ((this._p1 + 1) * t + this._p1 ) +1}), f ("BackIn", função (t) {return t * t * ((this._p1 + 1) * t-this._p1)}), f ("BackInOut", função (t) {return 1> (t * = 2) ?. 5 * t * t * ((this._p2 + 1) * t-this._p2) :. 5 * ((t- = 2) * t * ((este ._p2 + 1) * t + this._p2) +2)})), m = h ("easing.SlowMo", função (t, e, i) {e = e || 0 === e? e : .7, null == t? T = .7: t> 1 && (t = 1), este._p = 1! == t? E: 0, este._p1 = (1-t) / 2, este ._p2 = t, isto._p3 = isto._p1 + isto._p2, isto._calcEnd = i ===! 0} ,! 0), d = m.prototype = new t; return d.constructor = m, d .getRatio = function (t) {var e = t + (. 5-t) * this._p; retorna isso._p1> t? this._calcEnd? 1- (t = 1-t / this._p1) * t: e- (t = 1-t / this._p1) * t * t * t * e: t> this._p3? this._calcEnd? 1- (t = (t-this._p3) / this._p1) * t:e + (te) * (t = (t-this._p3) / this._p1) * t * t * t: this._calcEnd? 1: e}, m.ease = new m (.7, .7), d.config = m.config = função (t, e, i) {retorna novo m (t, e, i)}, e = h ("easing.SteppedEase", função (t) {t = t || 1 , this._p1 = 1 / t, this._p2 = t + 1} ,! 0), d = e.prototype = new t, d.constructor = e, d.getRatio = function (t) {return 0> t ? t = 0: t> = 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1}, d.config = e.config = function (t) {retorna novo e (t )}, i = h ("easing.RoughEase", função (e) {e = e || {}; para (var i, s, r, n, a, o, h = e.taper || "nenhuma ", l = [], _ = 0, u = 0 | (e.points || 20), f = u, p = e.randomize! ==! 1, m = e.clamp ===! 0, d = e.template instanceof t? e.plate: null, g = "number" == tipo de e.forte? .4 * e.forte: .4; - f> -1;) i = p? Math. Para obter mais informações, consulte a tabela a seguir. r = n * n * g): "in" === h? r = i * i * g: .5> i? (n = 2 * i, r = .5 * n * n * g) :( n = 2 * (1-i), r =.5 * n * n * g), p? S + = Math.random () * r-.5 * r: f% 2? S + =. 5 * r: s - =. 5 * r, m && (s> 1 ? s = 1: 0> s && (s = 0)), l [_ ++] = {x: i, y: s}; for (l.sort (função (t, e) {return tx-ex} ), o = new c (1,1, nulo), f = u; - f> -1;) a = l [f], o = new c (ax, ay, o); this._prev = new c (0,0,0! == ot? o: o.próximo)} ,! 0), d = i.prototype = novo t, d.constructor = i, d.getRatio = function (t) {var e = this._prev; if (t> et) {for (; e.next && t> = et;) e = e.next; e = e.prev} else para (; e.prev &&.t.t = t;) e = e.prev; retorne isso._prev = e, e.v + (te.t) /e.gap*ec}, d.config = função (t) {retorne novo i (t)}, i.ease = new i, u ("Bounce", l ("BounceOut", função (t) {return 1 / 2.75> t? 7.5625 * t * t: 2 / 2.75> t? 7.5625 * (t- = 1.5 / 2.75) * t + 0,75: 2,5 / 2,75> t? 7,5625 * (t- = 2,25 / 2,75) * t + .9375: 7,5625 * (t- = 2,625 / 2,75) * t + 0,984375}), l ("BounceIn", função (t ) {return 1 / 2,75> (t = 1-t)? 1-7,5625 * t * t: 2 / 2,75> t? 1- (7,5625 * (t- = 1,5 / 2,75) * t +.75): 2,5 / 2,75> t? 1- (7,5625 * (t- = 2,25 / 2,75) * t + 0,9375): 1- (7,5625 * (t- = 2,625 / 2,75) * t + 0,984375)}), l ("BounceInOut", função (t) {var e = 0,5> t; retorno t = e? 1-2 * t: 2 * t-1, t = 1 / 2,75> t? 7,5625 * t * t: 2 /2.75> t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75 ) * t + .984375, e? .5 * (1-t): 5 * t + .5})), u ("Circ", l ("CircOut", função (t) {return Math.sqrt (1 - (t- = 1) * t)}), l ("CircIn", função (t) {return- (Math.sqrt (1-t * t) -1)}), l ("CircInOut", função (t) {return 1> (t * = 2)? -. 5 * (Math.sqrt (1-t * t) -1): 5 * (Math.sqrt (1- (t- = 2) * t) +1)})), s = função (e, i, s) {var r = h ("flexibilização". + e, função (t, e) {this._p1 = t> = 1? t: 1, this._p2 = (e || s) / (1> t? T: 1), this._p3 = this._p2 / a * (Math.asin (1 / this._p1) || 0), este ._p2 = a / this._p2} ,! 0), n = r.prototype = new t; return n.constructor = r, n.getRatio = i, n.config = function (t,e) {retornar novo r (t, e)}, r}, u ("Elástico", s ("ElásticoOut", função (t) {retornar isso._p1 * Math.pow (2, -10 * t) * Math.sin ((t-this._p3) * this._p2) +1} ,. 3), s ("ElasticIn", função (t) {return- (this._p1 * Math.pow (2,10 * (t- = 1)) * Math.sin ((t-this._p3) * this._p2))}, 3), s ("ElasticInOut", função (t) {return 1> (t * = 2 )? -. 5 * this._p1 * Math.pow (2,10 * (t- = 1)) * Math.sin ((t-this._p3) * this._p2) :. 5 * this._p1 * Math.pow (2, -10 * (t- = 1)) * Math.sin ((t-this._p3) * this._p2) +1}, 45)), u ("Expo", l ( "ExpoOut", função (t) {retornar 1-Math.pow (2, -10 * t)}), l ("ExpoIn", função (t) {retornar Math.pow (2,10 * (t-1 )) -. 001}), l ("ExpoInOut", função (t) {return 1> (t * = 2) ?. 5 * Math.pow (2,10 * (t-1)): 5 * (2-Math.pow (2, -10 * (t-1)))})), u ("Seno", l ("SineOut", função (t) {retorna Math.sin (t * o)} ), l ("SineIn", função (t) {return-Math.cos (t * o) +1}), l ("SineInOut", função (t) {return-.5 * (Math.cos (Math.PI * t) -1)})), h ("atenuação. EaseLookup ", {find: function (e) {return t.map [e]}} ,! 0), _ (r.SlowMo," SlowMo "," facilidade "), _ (i," RoughEase "," facilidade, "), _ (e," SteppedEase "," facilidade ",), p} ,! 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () ();


/ *!
 * VERSÃO: 1.17.0
 * DATA: 27-05-2015
 * ATUALIZAÇÕES E DOCS EM: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. Todos os direitos reservados.
 * Este trabalho está sujeito aos termos em http://greensock.com/standard-license ou para
 * Membros do Club GreenSock, o contrato de software que foi emitido com a sua associação.
 * 
 * @ autor: Jack Doyle, jack@greensock.com
 * /
var _gsScope = "undefined"! = tipo de módulo && module.exports && "undefined"! = tipo de global? global: esta || janela; (_ gsScope._gsQueue || (_gsScope._gsQueue = [])). push (function () {" use strict "; _ gsScope._gsDefine (" plugins.CSSPlugin ", [" plugins.TweenPlugin "," TweenLite "], função (t, e) {vari, r, s, n, a = function () {t. chamada (this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio}, o = _gsScope._gsDefine.globals, l = {}, h = a.prototype = new t ( "css"); h.constructor = a, a.version = "1.17.0", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensado", a.defaultSmoothOrigin =! 0, h = "px", a.suffixMap = {superior: h, direita: h, inferior: h, esquerda: h, largura: h, altura: h, fontSize: h, preenchimento: h, margem: h, perspectiva: h, lineHeight : ""}; var u, f, c, p, _, d, m = / (?:\ d | \ - \ d | \. \ d | \ - \. \ d) + / g, g = / (?: \ d | \ - \ d | \. \ d | \ - \. \ d | \ + = \ d | \ - = \ d | \ + =. \ d | \ - = \. \ d) + / g, v = / (?: \ + = | \ - = | \ - | \ b ) [\ d \ - \.] + [a-zA-Z0-9] * (?:% | \ b) / gi, y = / (?! [+ -]? \ d * \.? \ d + | [+ -] | e [+ -] \ d +) [^ 0-9] / g, x = / (?: \ d | \ - | \ + | = | # | \.) * / g, T = / opacidade * = * ([^)] *) / i, w = / opacidade: ([^;] *) / i, b = / alfa \ (opacidade * =. +? \) / i, P = / ^ (rgb | hsl) /, S = / ([AZ]) / g, O = / - ([az]) / gi, k = / (^ (?: url \ (\ "| url \ ()) ) | (?: (\ "\)) $ | \) $) / gi, C = função (t, e) {retornar e.toUpperCase ()}, R = / (?: Esquerda | Direita | Largura) / i, A = / (M11 | M12 | M21 | M22) = [\ d \ - \. e] + / gi, M = / progid \: DXImageTransform \ .Microsoft \ .Matrix \ (. +? \) / i , D = /, (? = [^ \)] * (?: \ (| $)) / Gi, N = Math.PI / 180, L = 180 / Math.PI, F = {}, X = documento , z = função (t) {retornar X.createElementNS? X.createElementNS ("http://www.w3.org/1999/xhtml", t): X.createElement (t)}, B = z ("div "), E = z (" img "), I = a._internals = {_ specialProps: l}, Y = navigator.userAgent, W = function () {var t = Y.indexOf ("Android "), e = z (" a "); retornar c = -1! == Y.indexOf (" Safari ") && - 1 === Y.indexOf (" Chrome ") && (- 1 === t || Number (Y.substr (t + 8,1))> 3), _ = c && 6> Number (Y.substr (Y.indexOf ("Versão /") + 8,1)), p = -1 ! == Y.indexOf ("Firefox"), (/ MSIE ([0-9] {1,} [\. 0-9] {0,}) / .execut (Y) || / Trident \ /. * rv: ([0-9] {1,} [\. 0-9] {0,}) /. exec (Y)) && (d = parseFloat (RegExp. $ 1)), e? (e.style .cssText = "top: 1px; opacidade: 0,55;", / ^ 0,55 / .test (e.style.opacidade)) :! 1} (), V = function (t) {return T.test ("string "== tipo de t? t: (t.currentStyle? t.currentStyle.filter: t.style.filter) ||" ")? parseFloat (RegExp. $ 1) / 100: 1}, j = function (t) { window.console && console.log (t)}, G = "", U = "", q = função (t, e) {e = e || B; vari, r, s = e.style; if (void 0! == s [t]) retorna t; para (t = t.charAt (0) .toUpperCase () + t.substr (1), i = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; - r> -1 && void 0 === s [i [r] + t];); return r> = 0? (U = 3 === r? "Ms": i [r], G = "-" + U.toLowerCase () + "-", U + t): null}, H = X.defaultView? X. defaultView.getComputedStyle: function () {}, Q = a.getStyle = função (t, e, i, r, s) {var n; retorna W || "opacidade"! == e? (! r && t.style [ e]? n = t.style [e] :( i = i || H (t))? n = i [e] || i.getPropertyValue (e) || i.getPropertyValue (e.replace (S, "- $ 1"). ToLowerCase ()): t.currentStyle && (n = t.currentStyle [e]), null == s || n && "none"! == n && "auto"! == n && "auto auto" ! == n? n: s): V (t)}, Z = I.convertToPixels = função (t, i, r, s, n) {if ("px" === s ||! s) return r; if ("auto" === s ||! r) retorna 0; var o, l, h, u = R.teste (i), f = t, c = B.style, p = 0> r ; if (p && (r = -r), "%" === s && - 1!== i.indexOf ("borda")) o = r / 100 * (u? t.clientWidth: t.clientHeight); senão {if (c.cssText = "borda: 0 vermelho sólido; posição:" + Q ( t, "position") + "; line-height: 0;", "%"! == s && f.appendChild) c [u? "borderLeftWidth": "borderTopWidth"] = r + s; else {if (f = t.parentNode || X.body, l = f._gsCache, h = e.ticker.frame, l && u && l.time === h) retornar l.width * r / 100; c [u? "width": "height "] = r + s} f.appendChild (B), o = parseFloat (B [u?" offsetWidth ":" offsetHeight "]), f.removeChild (B), u &&"% "=== s && a.cacheWidths! ==! 1 && (l = f._gsCache = f._gsCache || {}, l.time = h, l.width = 100 * (o / r)), 0! == o || n || (o = Z (t, i, r, s,! 0))} retorna p? -O: o}, $ = I.calculateOffset = function (t, e, i) {if ("absoluto"! == Q ( t, "posição", i)) retorna 0; var r = "esquerda" === e? "Esquerda ":" Superior ", s = Q (t," margem "+ r, i); retorna t [" deslocamento "+ r] - (Z (t, e, parseFloat (s), s.replace (x, "")) || 0)}, K = função (t, e) {var i, r, s, n = {}; se (e = e || H (t, nulo)) if (i = e .length) para (; - i> -1;) s = e [i], (- 1 === s.indexOf ("- transform") || Pe === s) && (n [s. substitua (O, C)] = e.getPropertyValue (s)); caso contrário, para (i em e) (- 1 === i.indexOf ("Transform") || be === i) && (n [i ] = e [i]); caso contrário, se (e = t.currentStyle || t.style) para (i em e) "string" == tipo de i && void 0 === n [i] && (n [i.replace (O, C)] = e [i]); retorne W || (n.opacidade = V (t)), r = Xe (t, e,! 1), n.rotation = r.rotation, n. skewX = r.skewX, n.scaleX = r.scaleX, n.scaleY = r.scaleY, nx = rx, ny = ry, Oe && (nz = rz, n.rotationX = r.rotationX, n.rotationY = r. rotaçãoY, n.scaleZ = r.scaleZ), n.filters && delete n.filters, n}, J = função (t, e, i, r, s) {var n, a, o, l = {}, h = t.style;para (a em i) "cssText"! == a && "length"! == a && isNaN (a) && (e [a]! == (n = i [a]) || s && s [a]) && - 1 === a.indexOf ("Origem") && ("número" == tipo de n || "string" == tipo de n) && (l [a] = "automático"! == n || "restante"! == a && "top"! == a? ""! == n && "auto"! == n && "none"! == n || "string"! = typeof e [a] || "" === e [a] .place (y, "")? n: 0: $ (t, a), void 0! == h [a] && (o = new pe (h, a, h [a], o )));; se (r) para (a em r) "className"! == a && (l [a] = r [a]); return {difs: l, firstMPT: o}}, te = {width: ["Esquerda", "Direita"], altura: ["Superior", "Inferior"]}, ee = ["marginLeft", "marginRight", "marginRight", "marginTop", "marginBottom"], ie = função (t, e ,i) {var r = parseFloat ("width" === e? t.offsetWidth: t.offsetHeight), s = te [e], n = s.length; para (i = i || H (t, nulo ); - n> -1;) r- = parseFloat (Q (t, "preenchimento" + s [n], i,! 0)) || 0, r- = parseFloat (Q (t, "borda") + s [n] + "Largura", i,! 0)) || 0; retornar r}, re = função (t, e) {(null == t || "" === t || "auto "=== t ||" auto automático "=== t) && (t =" 0 0 "); vari = divisão de t (" "), r = -1! == t.indexOf (" left ")?" 0% ": - 1! == t.indexOf (" right ")?" 100% ": i [0], s = -1! == t.indexOf (" top ")?" 0 % ": - 1! == t.indexOf (" bottom ")?" 100% ": i [1]; retorno nulo == s? S =" center "=== r?" 50% ":" 0 ":" center "=== s && (s =" 50% "), (" center "=== r || isNaN (parseFloat (r)) && - 1 === (r +" "). indexOf (" = ")) && (r ="50% "), t = r +" "+ s + (comprimento i> 2?" "+ I [2]:" "), e && (e.oxp = -1! == r.indexOf ("% ") , e.oyp = -1! == s.indexOf ("%"), e.oxr = "=" === r.charAt (1), e.oyr = "=" === s.charAt ( 1), e.ox = parseFloat (r.replace (y, "")), e.oy = parseFloat (s.replace (y, "")), ev = t), e || t}, se = função (t, e) {return "string" == tipo de t && "=" === t.charAt (1)? parseInt (t.charAt (0) + "1", 10) * parseFloat (t.substr ( 2)): parseFloat (t) -parseFloat (e)}, ne = função (t, e) {return null == t? E: "string" == typeof t && "=" === t.charAt (1) )? parseInt (t.charAt (0) + "1", 10) * parseFloat (t.substr (2)) + e: parseFloat (t)}, ae = function (t, e, i, r) {var s, n, a, o, l, h = 1e-6; return null == t? o = e: "number" == typeof t? o = t: (s = 360, n = t.split (" _ "), l =" = "=== t.charAt (1),a = (l? parseInt (t.charAt (0) + "1", 10) * parseFloat (n [0] .substr (2)): parseFloat (n [0])) * (- 1 === t .indexOf ("rad")? 1: L) - (l? 0: e), n.length && (r && (r [i] = e + a), - 1! == t.indexOf ("short") && (a% = s, a! == a% (s / 2) && (a = 0> a? a + s: as)), - 1! == t.indexOf ("_ cw") && 0> a ? a = (a + 9999999999 * s)% s- (0 | a / s) * s: -1! == t.indexOf ("ccw") && a> 0 && (a = (a-9999999999 * s)% s- (0 | a / s) * s)), o = e + a), h> o && o> -h && (o = 0), o}, oe = {aqua: [0,255,255], cal: [0,255, 0], prata: [192,192,192], preto: [0,0,0], marrom: [128,0,0], cerceta: [0,128,128], azul: [0,0,255], marinha: [0,0,128] , branco: [255,255,255], fúcsia: [255,0,255], oliva: [128,128,0], amarelo: [255,255,0], laranja: [255,165,0], cinza: [128,128,128], roxo: [128, 0,128], verde: [0,128,0], vermelho: [255,0,0], rosa: [255,192,203], ciano: [0,255,255], transparente: [255,255,255,0]},le = função (t, e, i) {retornar t = 0> t? t + 1: t> 1? t-1: t, 0 | 255 * (1> 6 * t? e + 6 * (ie) * t: .5> t? i: 2> 3 * t? e + 6 * (ie) * (2/3-t): e) +. 5}, ele = a.parseColor = function (t) { var e, i, r, s, n, a; return t && ""! == t? "number" == typeof t? [t >> 16.255 et t >> 8.255 & t] :( "," === t .charAt (t.length-1) && (t = t.substr (0, t.length-1)), oe [t]? oe [t]: "#" === t.charAt (0)? (4 === comprimento t && (e = t.charAt (1), i = t.charAt (2), r = t.charAt (3), t = "#" + e + e + i + i + r + r), t = parseInt (t.substr (1), 16), [t >> 16.255 & t >> 8.255 & t]): "hsl" === t.substr (0,3)? (t = t.match (m), s = Número (t [0])% 360/360, n = Número (t [1]) / 100, a = Número (t [2]) / 100, i = 0,5> = a? a * (n + 1): a + na * n, e = 2 * ai, comprimento t> 3 && (t [3] = número (t [3])), t [0] = le ( s + 1/3, e, i), t [1] = le (s, e, i), t [2] = le (s-1/3, e, i), t) :( t = t .match (m) || oe.transparent, t [0] = Número (t [0]),t [1] = Número (t [1]), t [2] = Número (t [2]), comprimento t> 3 && (t [3] = Número (t [3])), t)): oe.black}, ue = "(?: \\ b (? :( ?: rgb | rgba | hsl | hsla) \\ (. +? \\)) | \\ B #. +? \\ b"; for (h in oe) ue + = "|" + h + "\\ b"; ue = RegExp (ue + ")", "gi"); var fe = function (t, e, i, r) {if (null == t) função de retorno (t) {return t}; var s, n = e? (t.match (ue) || [""]) [0]: "", a = t.split (n) .join (""). match (v) || [], o = t.substr (0, t.indexOf (a [0])), l = ")" === t.charAt (t.length -1)? ")": "", H = -1! == t.indexOf ("")? "": ",", U = comprimento, f = u> 0? A [0]. substitua (m, ""): ""; retorne u? s = e? função (t) {var e, c, p, _; if ("number" == tipo de t) t + = f; caso contrário, se (r && D .test (t)) {for (_ = t.replace (D, "|"). split ("|"), p = 0; _. length> p; p ++) _ [p] = s (_ [ p]); retorne _.join (",")} if (e = (t.match (ue) || [n]) [0], c = t.split (e) .join (""). match (v) || [], p = c .length, u> p -) para (; u> ++ p;) c [p] = i? c [0 | (p-1) / 2]: a [p]; return o + c.join (h) + h + e + l + (- 1! == t.indexOf ("inserção")? "inserção": "")}: função (t) {var e, n, c; if ("number" == typeof t) t + = f; caso contrário, se (r && D.test (t)) {for (n = t.replace (D, "|"). split ("|"), c = 0; n.length> c; c ++) n [c] = s (n [c]); retorna n.join (",")} se (e = t.match (v) || [], c = e.length, u> c -) para (; u> ++ c;) e [c] = i? e [0 | (c-1) / 2]: a [c]; retorno o + e.join (h) + l }: função (t) {retorno t}}, ce = função (t) {retorno t = t.split (","), função (e, i, r, s, n, a, o) {var l , h = (i + ""). split (""); para (o = {}, l = 0; 4> l; l ++) o [t [l]] = h [l] = h [l] | | h [(l-1) / 2 >> 0]; return s.parse (e, o, n, a)}}, pe = (I._setPluginRatio = function (t) {this.plugin.setRatio (t ); para (var e, i, r, s, n = this.data, a = n.proxy, o = n.firstMPT, l = 1e-6; o;) e = a [ov] ou? e = Math.round (e): l> e && e> -l && (e = 0), ot [op ] = e, o = o._next; if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t) para (o = n.firstMPT; o;) {if (i = ot , i.type) {if (1 === i.type) {for (s = i.xs0 + i.s + i.xs1, r = 1; il> r; r ++) s + = i ["xn" + r] + i ["xs" + (r + 1)]; ie = s}} senão = i.s + i.xs0; o = o._next}}, função (t, e, i, r , s) {this.t = t, this.p = e, this.v = i, this.r = s, r && (r._prev = this, this._next = r)}), _ e = (I. _parseToProxy = função (t, e, i, r, s, n) {var a, o, l, h, u, f = r, c = {}, p = {}, _ = i._transform, d = F; para (i._trxs "+ (r + 1)]; ie = s}} else ie = i.s + i.xs0; o = o._next}}, função (t, e, i, r, s) {this.t = t, this.p = e, this.v = i, this.r = s, r && (r._prev = this, this._next = r)}), _ e = (I._parseToProxy = function (t, e , i, r, s, n) {var a, o, l, h, u, f = r, c = {}, p = {}, _ = transformação i, d = F; for (i._trxs "+ (r + 1)]; ie = s}} else ie = i.s + i.xs0; o = o._next}}, função (t, e, i, r, s) {this.t = t, this.p = e, this.v = i, this.r = s, r && (r._prev = this, this._next = r)}), _ e = (I._parseToProxy = function (t, e , i, r, s, n) {var a, o, l, h, u, f = r, c = {}, p = {}, _ = transformação i, d = F; for (i._tr"+ _: _; if (-1! == r.indexOf (" = ") && a.data) {para (S = a.xs0 + a.data.s, f = 1; al> f; f ++) S + = a ["xs" + f] + a.data ["xn" + f]; ae = S + a ["xs" + f]} retorna al || (a.type = -1, a.xs0 = ae), a.xfirst || a}, ge = 9; for (h = _e.prototype, hl = h.pr = 0; - ge> 0;) h ["xn" + ge] = 0, h ["xs" + ge] = ""; h.xs0 = "", h.next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = nulo, h .appendXtra = função (t, e, i, r, s, n) {var a = isto, o = al; retorna a ["xs" + o] + = n && o? " "+ t: t ||" ", i || 0 === o || a.plugin? (a.l ++, a.type = a.setRatio? 2: 1, a [" xs "+ al] = r || "", o> 0? (a.data ["xn" + o] = e + i, a.rxp ["xn" + o] = s, a ["xn" + o] = e, a.plugin || (a.xfirst = novo _e (a, "xn" + o, e, i, a.xfirst || a, 0, an, s, a.pr), a.xfirst.xs0 = 0 ), a) :( a.data = {s: e + i}, a.rxp = {}, como = e, ac = i, ar = s, a)) :( a ["
var h, p, d, m, g, v, y, x, T, b = t.style; if (f && "" === b.zIndex && (h = Q (t, "zIndex", s), ("auto" === h || "" === h) && this._addLazySet (b, "zIndex", 0)), "string" == tipo de e&& (m = b.cssText, h = K (t , s), b.cssText = m + ";" + e, h = J (t, h, K (t)). difs,! W && w.test (e) && (h.opacity = parseFloat (RegExp. $ 1) ), e = h, b.cssText = m), this._firstPT = p = e.className? l.className.parse (t, e.className, "className", este, nulo, nulo, e): this. análise (t, e, nulo), this._transformType) {for (T = 3 === this._transformType, be? c && (f =! 0, "" === b.zIndex && (y = Q (t, "zIndex", s), ("auto" === y || "" === y) && this._addLazySet (b, "zIndex", 0)), _ && this._addLazySet (b, "WebkitBackfaceVisibility", isso. _vars.WebkitBackfaceVisibility || (T? "visível ":" oculto "))): b.zoom = 1, d = p; d && d._next;) d = d._next; x = novo _e (t," transformação ", 0,0, nulo, 2) , this._linkCSSP (x, null, d), x.setRatio = be? Be: ze, x.data = this._transform || Xe (t, s,! 0), x.tween = o, x.pr = -1, n.pop ()} se (i) {for (; p;) {for (v = p._next, d = m; d && d.pr> p.pr;) d = d._next; ( p._prev = d? d._prev: g)? p._prev._next = p: m = p, (p._next = d)? d._prev = p: g = p, p = v} this._firstPT = m} retorna! 0}, h.parse = função (t, e, i, n) {var a, o, h, f, c, p, _, d, m, g, v = t.style; Para (a em e) p = e [a], o = l [a], o? i = o.parse (t, p, a, isto, i, n, e) :( c = Q (t, a, s) + "", m = "string" == tipo de p, "cor" === a || "preenchimento" === a || "traço" === a || -1! == a.indexOf ("Cor") || m && P.test (p)? (m || (p = ele (p), p = (comprimento de p>> 3? "rgba (": "rgb (") + p .join (",") + ")"), i = eu (v, a, c, p,! 0, "transparente", i, 0, n)) :! m || -1 === p .indexOf ("") && - 1 === p.indexOf (",")? (h = parseFloat (c), _ = h || 0 === h? c.substr ((h + ""). length ): "", ("" === c || "auto" === c) && ("largura" === a || "altura" === a? (h = ie (t, a, s), _ = "px"): "left" === a || "top" === a? (h = $ (t, a, s), _ = "px") :( h = " opacidade "! == a? 0: 1, _ =" ")), g = m &&" = "=== p.charAt (1), g? (f = parseInt (p.charAt (0) +" 1 ", 10), p = p.substr (2), f * = parseFloat (p), d = p.replace (x," ")) :( f = parseFloat (p), d = m? P.replace (x, ""): ""), "" === d && (d = a em r? r [a]: _), p = f || 0 === f? (g? f + h: f) + d: e [a], _! == d && ""! == d && (f || 0 === f) && h && (h = Z (t, a, h, _), "%" = == d? (h / = Z (t, a, 100, "%") / 100, e.strictUnits! ==! 0 && (c = h + "%")): "em "=== d? h / = Z (t, a, 1," em "):" px "! == d && (f = Z (t, a, f, d), d =" px ") , g && (f || 0 === f) && (p = f + h + d)), g && (f + = h) ,! h && 0! == h ||! f && 0! == f? void 0! = = v [a] && (p || "NaN"! = p + "" && null! = p)? (i = novo _e (v, a, f || h || 0,0, i, -1, a ,! 1,0, c, p), i.xs0 = "nenhum"! == p || "exibição"! == a && - 1 === a.indexOf ("Estilo")? P: c): j ("inválido" + a + "valor da interpolação:" + e [a]) :( i = novo _e (v, a, h, fh, i, 0, a, u! ==! 1 && ("px" = == d || "zIndex" === a), 0, c, p), i.xs0 = d)): i = eu (v, a, c, p,! 0, nulo, i, 0, n)), n && i &&! i.plugin && (i.plugin = n); return i}, h.setRatio = function (t) {var e, i, r, s = this._firstPT, n = 1e-6; if (1! == t || this._tween._time! == this._tween._duration && 0! == this._tween._time) if (t || this._tween._time! == this._tween._duration && 0! == this._tween._time || this._tween._rawPrevTime === - 1e-6) para (; s;) {if (e = sc * t + ss, sr? e = Math.round (e ): n> e && e> -n && (e = 0), s.type) if (1 === s.type) if (r = sl, 2 === r) st [sp] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2; caso contrário, se (3 === r) st [sp] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s .xs3; caso contrário, se (4 === r) st [sp] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3 + s.xn3 + s.xs4 ; caso contrário, se (5 === r) st [sp] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3 + s.xn3 + s.xs4 + s .xn4 + s.xs5; else {for (i = s.xs0 + e + s.xs1, r = 1; sl> r; r ++) i + = s ["xn" + r] + s ["xs" + (r + 1)]; st [sp] = i} mais-1 === s.type? st [sp] = s.xs0: s.setRatio && s.setRatio (t); else st [sp] = e + s.xs0; s = s._next} else for (; s;) 2! == s.type? st [sp] = sb: s.setRatio (t), s = s._next; else for (; s ;) {if (2! == s.type) if (sr && - 1! == s.type) if (e = Math.round (s.s + sc), s.type) {if (1 == = s.type) {for (r = sl, i = s.xs0 + e + s.xs1, r = 1; sl> r;r ++) i + = s ["xn" + r] + s ["xs" + (r + 1)]; st [sp] = i}} else st [sp] = e + s.xs0; else st [sp ] = se; else s.setRatio (t); s = s._next}}, h._TransableTransforms = function (t) {this._transform = this._transform || Xe (this._target, s,! 0), this._transformType = this._transform.svg && Te ||! t && 3! == this._transformType? 2: 3}; var Ve = function () {this.t [this.p] = this.e, this.data._linkCSSP (this, this._next, null,! 0)}; h._addLazySet = function (t, e, i) {var r = this._firstPT = new _e (t, e, 0,0, this._firstPT, 2 ); re = i, r.setRatio = Ve, r.data = isso}, h._linkCSSP = função (t, e, i, r) {return t && (e && (e._prev = t), t._next && ( t._next._prev = t._prev), t._prev? t._prev._next = t._next: this._firstPT === t && (this._firstPT = t._next, r =! 0), i? i ._next = t: r || nulo! == this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t}, h.kill = function (e) { var i, r, s, n = e; if (e.autoAlpha || e.alpha) {n = {};for (r in e) n [r] = e [r]; n.opacity = 1, n.autoAlpha && (n.visibility = 1)} retorne e.className && (i = this._classNamePT) && (s = i. xfirst, s && s._prev? this._linkCSSP (s._prev, i._next, s._prev._prev): s === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP (i. _next, i._next._next, s._prev), this._classNamePT = null), t.prototype._kill.call (this, n)}; var je = function (t, e, i) {var r, s , n, a; if (t.slice) for (s = t.length; - s> -1;) je (t [s], e, i); else for (r = t.childNodes, s = r.length; - s> -1;) n = r [s], a = n.type, n.style && (e.push (K (n)), i && i.push (n)), 1! = = a && 9! == a && 11! == a ||! n.childNodes.length || je (n, e, i)}; retorne a.cascadeTo = function (t, i, r) {var s, n, a , o, l = e.to (t, i, r), h = [l], u = [], f = [], c = [], p = e._internals.reservedProps; for (t = l ._targets || l.target, je (t, u, c), l.render (i,! 0,! 0), je (t, f), l.render (0,! 0,! 0), l._ ativado (! 0), s = c.comprimento; - s> -1;) if (n = J (c [s], u [s], f [s]), n.firstMPT) {n = n.difs; para (a em r) p [a] && (n [a] = r [a]); o = {}; para (a em n) o [a] = u [s] [a]; h.push (e.fromTo (c [ s], i, o, n))} retornar h}, t.ativar ([a]), a}, 0)}), _ gsScope._gsDefine && _ gsScope._gsQueue.pop () (), function (t) { "use strict"; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]}; "function" == tipo de definição && define.amd? define (["TweenLite"], e): "indefinido" ! = typeof module && module.exports && (require ("../ TweenLite.js"), module.exports = e ())} ("CSSPlugin");use strict "; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]};" function "== tipo de define && define.amd? define ([" TweenLite "], e):" indefinido "! = typeof module && module.exports && (require ("../ TweenLite.js"), module.exports = e ())} ("CSSPlugin");use strict "; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]};" function "== tipo de define && define.amd? define ([" TweenLite "], e):" indefinido "! = typeof module && module.exports && (require ("../ TweenLite.js"), module.exports = e ())} ("CSSPlugin");

/ *!
 * VERSÃO: beta 0.3.3
 * DATA: 29/10/2014
 * ATUALIZAÇÕES E DOCS EM: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. Todos os direitos reservados.
 * SplitText é um benefício de associação ao Club GreenSock; Você deve ter uma associação válida para usar
 * este código sem violar os termos de uso. Visite http://www.greensock.com/club/ para se inscrever ou obter mais detalhes.
 * Este trabalho está sujeito ao contrato de software que foi emitido com sua associação.
 * 
 * @ autor: Jack Doyle, jack@greensock.com
 * /
var _gsScope = "undefined"! = tipo de módulo && module.exports && "undefined"! = tipo de global? global: esta || janela; (função (t) {"use strict"; var e = t.GreenSockGlobals || t, i = função (t) {var i, s = t.split ("."), r = e; para (i = 0; s.length> i; i ++) r [s [i]] = r = r [s [i]] || {}; retorna r}, s = i ("com.greensock.utils"), r = função (t) {var e = t.nodeType, i = ""; if (1 == = e || 9 === e || 11 === e) {if ("string" == tipo de t.textContent) retorna t.textContent; for (t = t.firstChild; t; t = t.nextSibling ) i + = r (t)} else if (3 === e || 4 === e) retorna t.nodeValue; retorna i}, n = documento, a = n.defaultView? n.defaultView.getComputedStyle: function () {}, o = / ([AZ]) / g, h = função (t, e, i, s) {var r; return (i = i || a (t, nulo))? (t = i.getPropertyValue (e.replace (o, "- $ 1"). toLowerCase ()), r = t || i.length? t: i [e]): t.currentStyle && (i = t.currentStyle, r = i [e]), s? r:parseInt (r, 10) || 0}, l = função (t) {retorna t.length && t [0] && (t [0] .nodeType && t [0] .style &&! t.nodeType || t [0] .length && t [0] [0]) ?! 0:! 1}, _ = função (t) {var e, i, s, r = [], n = comprimento de t; para (e = 0; n> e; e ++) if (i = t [e], l (i)) para (s = i.length, s = 0; i.length> s; s ++) r.push (i [s]); else r.push (i); return r}, u = ") eefec303079ad17405c", c = / (?: <br> | <br \ /> | <br \/>) /gi,f=n.all &&! n.addEventListener, p = "<div style = 'posição: relativa; display: bloco inline;" + (f? "* display: inline; * zoom: 1;'": "'"), m = função (t) {t = t || ""; var e = -1! == t.indexOf ("++"), i = 1; retorna e && (t = t.split ("++"). join ("")) , function () {return p + (t? "class = '" + t + (e? i ++: "") + "'>": ">")}}, d = s.SplitText = e.SplitText = function ( te) {if ("string" == tipo de t && (t = d.seletor (t)) ,! t) throw "não pode dividir um elemento nulo."; this.elements = l (t)? _ (t): [t], this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split (e)}, g = função (t, e, i) {var s = t.nodeType; if (1 === s || 9 === s || 11 === s) para (t = t.firstChild; t; t = t.nextSibling) g (t, e, i); else (3 === s || 4 === s) && (t.nodeValue = t.nodeValue.split (e) .join (i)) }, v = função (t, e) {para (var i = comprimento e; - i> -1;) t.push (e [i])}, y = função (t, e, i, s , o) {c.test (t.innerHTML) && (t.innerHTML = t.innerHTML.replace (c, u)); var l, _, f, p, d, y, T, w, b, x , P, S, k, C, R = r (t), O = e.type || e.split || "caracteres, palavras, linhas", A = -1! == O.indexOf ("linhas" )? []: null, D = -1! == O.indexOf ("palavras"), M = -1! == O.indexOf ("caracteres"), L = "absoluto" === e.position || e.absolute ===! 0, z = L? "& # 173;": "",I = -999, E = a (t), N = h (t, "paddingLeft", E), F = h (t, "borderBottomWidth", E) + h (t, "borderTopWidth", E), B = h (t, "borderLeftWidth", E) + h (t, "borderRightWidth", E), X = h (t, "paddingTop", E) + h (t, "paddingBottom", E), j = h (t, "paddingLeft", E) + h (t, "paddingRight", E), U = h (t, "textAlign", E,! 0), Y = t.clientHeight, q = t.clientWidth, V = "</div>", G = m (e.wordsClass), Q = m (e.charsClass), W = -1! == (e.linesClass || ""). indexOf ("++") , Z = e.linesClass, H = -1! == R.indexOf ("<"), $ =! 0, K = [], J = [], te = []; para (W && (Z = Z .split ("++"). join ("")), H&& (R = R.split ("<"). join ("{{LT}}")), l = R.length, p = G (), d = 0; l> d; d ++) if (T = R.charAt (d), ")" === T && R.substr (d, 20) === u) p + = ($? V: "") + "<BR/>", $ =! 1, d!== l-20 && R.substr (d + 20,20)! == u && (p + = "" + G (), $ =! 0), d + = 19; caso contrário, se ("" === T&& ""! == R.charAt (d-1) && d! == l-1 && R.substr (d-20,20)! == u) {for (p + = $? V: "", $ =! 1; "" === R.charAt (d + 1);) p + = z, d ++; (")"! == R.charAt (d + 1) || R.substr (d + 1,20)! == u ) && (p + = z + G (), $ =! 0)} else p + = M&& ""! == T? Q () + T + "</div>": T; para (t.innerHTML = p + ( $? V: ""), H && g (t, "{{LT}}", "<"), y = t.getElementsByTagName ("*"), l = comprimento de y, w = [], d = 0 ; l> d; d ++) w [d] = y [d]; se (A || L) para (d = 0; l> d; d ++) b = w [d], f = b.parentNode == = t, (f || L || M &&! D) && (x = b.offsetTop, A && f && x! == I && "BR"! == b.nodeName && (_ = [], A.push (_), I = x), L && (b._x = b.offsetLeft, b._y = x, b._w = b.offsetWidth, b._h = b.offsetHeight), A && (D! == f && M || (_. Push (b), b._x- = N), f && d && (w [d-1] ._ wordEnd =! 0), "BR" === b.nodeName && b. nextSibling && "BR" === b.nextSibling.nodeName && A.push ([]))); for (d = 0; l> d; d ++) b = w [d], f = b.parentNode === t, "BR"! == b.nodeName? (L && (S = b.style, D || f || (b._x + = b.parentNode._x, b._y + = b.parentNode._y), S.left = b._x + "px", S.top = b._y + "px", S.position = "absolute", S.display = "block", S.width = b._w + 1 + "px", S .height = b._h + "px"), D? f && ""! == b.innerHTML? J.push (b): M&& K.push (b): f? (t.removeChild (b), w.splice (d -, 1), l -) :! f && M && (x =! A &&! L && b.nextSibling, t.appendChild (b), x || t.appendChild (n.createTextNode ("")), K. push (b))): A || L? (t.removeChild (b), w.splice (d -, 1), l -): D || t.appendChild (b);se (A) {para (L && (P = n.criarElement ("div")), t.appendChild (P), k = P.offsetWidth + "px", x = P.offsetParent === t? 0: t. offsetLeft, t.removeChild (P)), S = t.style.cssText, t.style.cssText = "display: none;"; t.firstChild;) t.removeChild (t.firstChild); for (C =! L ||! D &&! M, d = 0; A. comprimento> d; d ++) {para (_ = A [d], P = n.criarElement ("div"), P.style.cssText = "display: bloco; alinhamento de texto: "+ U +"; posição: "+ (L?" absoluto; ":" relativo; "), Z && (P.className = Z + (W? d + 1:" ")), te. push (P), l = _. comprimento, y = 0; l> y; y ++) "BR"! == _ [y] .nodeName && (b = _ [y], P.appendChild (b), C && ( b._wordEnd || D) && P.appendChild (n.createTextNode ("")), L && (0 === y && (P.style.top = b._y + "px", P.style.left = N + x + "px"), b.style.top = "0px", x && (b.style.left = b._x-x + "px"))); 0 === l && (P.innerHTML = "& nbsp;"), D || M || (P.innerHTML = r (P) .split (String. fromCharCode (160)). join ("")), L && (P.style.width = k, P.style.height = b._h + "px"), t.appendChild (P)} t.style.cssText = S} L && (Y> t.clientHeight && (t.style.height = Y-X + "px", Y> t.clientHeight && (t.style.height = Y + F + "px")), q> t.clientWidth && ( t.style.width = q-j + "px", q> t.clientWidth && (t.style.width = q + B + "px"))), v (i, K), v (s, J), v (o, te)}, T = d.prototype; T.split = function (t) {this.isSplit && this.revert (), this.vars = t || this.vars, this._originals.length = this.chars .length = this.words.length = this.lines.length = 0; para (var e = this.elements.length; - e> -1;) this._originals [e] = this.elements [e]. innerHTML, y (isto.elementos [e], isto.vars, isto.chars, isto.palavras, this.lines); retorna this.chars.reverse (), this.words.reverse (), this.lines.reverse (), this.isSplit =! 0, this}, T.revert = function () { se (! this._originals) throw "chamada revert () não tiver o escopo definido corretamente"; for (var t = this._originals.length; - t> -1;) this.elements [t] .innerHTML = this ._originals [t]; retorna this.chars = [], this.words = [], this.lines = [], this.isSplit =! 1, this}, d.selector = t. $ || t.jQuery || function (e) {var i = t. $ || t.jQuery; return i? (d.selector = i, i (e)): "undefined" == tipo de documento? e: document.querySelectorAll? document .querySelectorAll (e): document.getElementById ("#" === e.charAt (0)? e.substr (1): e)}, d.version = "0.3.3"}) (_ gsScope), função (t) {"use strict"; var e = function () {return (_gsScope.GreenSockGlobals || _gsScope) [t]}; "function" == tipo de definição && define.amd? define (["TweenLite"], e) : "undefined "! = tipo de módulo && module.exports && (module.exports = e ())} (" SplitText ");

experimentar{
	window.GreenSockGlobals = null;
	window._gsQueue = null;
	window._gsDefine = null;

	delete (window.GreenSockGlobals);
	delete (window._gsQueue);
	delete (window._gsDefine);	
   } captura (e) {}

experimentar{
	window.GreenSockGlobals = oldgs;
	window._gsQueue = oldgs_queue;
	} captura (e) {}

if (window.tplogs == true)
	experimentar {
		console.groupEnd ();
	} captura (e) {}

(função (e, t) {
		e.waitForImages = {hasImageProperties: ["backgroundImage", "listStyleImage", "borderImage", "borderCornerImage"]}; e.expr [":"]. uncached = função (t) {var n = document.createElement (" img "); n.src = t.src; retorna e (t) .is ('img [src! =" "]') &&! n.complete}; e.fn.waitForImages = função (t, n, r) {if (e.isPlainObject (argumentos [0])) {n = t.each; r = t.waitForAll; t = t.finished} t = t || e.noop; n = n || e. noop; r = !! r; if (! e.isFunction (t) ||! e.isFunction (n)) {lança novo TypeError ("Um retorno de chamada inválido foi fornecido.")} retorne this.each (function () {var i = e (this), s = []; if (r) {var o = e.waitForImages.hasImageProperties || [], u = / url \ ((['"]?) (. *?) \ 1 \) / g; i.find ("*"). Each (function () {var t = e (this); if (t.is ("img: uncached")) {s.push ({src : t.attr ("src"), elemento: t [0]})} e.each (o, função (e,n) {var r = t.css (n); if (! r) {return true} var i; while (i = u.exec (r)) {s.push ({src: i [2], elemento : t [0]})}})})} else {i.find ("img: uncached"). each (function () {s.push ({src: this.src, elemento: this})}) } var f = s.length, l = 0; se (f == 0) {t.call (i [0])} e.each (s, função (r, s) {var o = nova imagem; e (o) .bind ("erro de carregamento", função (e) {l ++; n.call (s.element, l, f, e.type == "load"); if (l == f) {t. chamar (i [0]); retornar false}}); o.src = s.src})})};		
}) (jQuery)